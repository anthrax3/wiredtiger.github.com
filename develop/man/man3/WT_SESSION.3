.TH "WT_SESSION" 3 "Sat Apr 11 2015" "Version Version 2.5.3" "WiredTiger" \" -*- nroff -*-
.ad l
.nh
.SH NAME
WT_SESSION \- 
.PP
All data operations are performed in the context of a \fBWT_SESSION\fP\&.  

.SH SYNOPSIS
.br
.PP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "int \fBclose\fP (\fBWT_SESSION\fP *session, const char *config)"
.br
.RI "\fIClose the session handle\&. \fP"
.ti -1c
.RI "int \fBreconfigure\fP (\fBWT_SESSION\fP *session, const char *config)"
.br
.RI "\fIReconfigure a session handle\&. \fP"
.ti -1c
.RI "const char * \fBstrerror\fP (\fBWT_SESSION\fP *session, int error)"
.br
.RI "\fIReturn information about an error as a string\&. \fP"
.in -1c
.PP
.RI "\fBCursor handles\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "int \fBopen_cursor\fP (\fBWT_SESSION\fP *session, const char *uri, \fBWT_CURSOR\fP *to_dup, const char *config, \fBWT_CURSOR\fP **cursorp)"
.br
.RI "\fIOpen a new cursor on a data source or duplicate an existing cursor\&. \fP"
.in -1c
.in -1c
.PP
.RI "\fBTable operations\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "int \fBcreate\fP (\fBWT_SESSION\fP *session, const char *name, const char *config)"
.br
.RI "\fICreate a table, column group, index or file\&. \fP"
.ti -1c
.RI "int \fBcompact\fP (\fBWT_SESSION\fP *session, const char *name, const char *config)"
.br
.RI "\fICompact a live row- or column-store btree or LSM tree\&. \fP"
.ti -1c
.RI "int \fBdrop\fP (\fBWT_SESSION\fP *session, const char *name, const char *config)"
.br
.RI "\fIDrop (delete) an object\&. \fP"
.ti -1c
.RI "int \fBlog_printf\fP (\fBWT_SESSION\fP *session, const char *fmt,\&.\&.\&.)"
.br
.RI "\fIInsert a \fBWT_LOGREC_MESSAGE\fP type record in the database log files (the database must be configured for logging when this method is called)\&. \fP"
.ti -1c
.RI "int \fBrename\fP (\fBWT_SESSION\fP *session, const char *uri, const char *newuri, const char *config)"
.br
.RI "\fIRename an object\&. \fP"
.ti -1c
.RI "int \fBsalvage\fP (\fBWT_SESSION\fP *session, const char *name, const char *config)"
.br
.RI "\fISalvage a file or table\&. \fP"
.ti -1c
.RI "int \fBtruncate\fP (\fBWT_SESSION\fP *session, const char *name, \fBWT_CURSOR\fP *start, \fBWT_CURSOR\fP *stop, const char *config)"
.br
.RI "\fITruncate a file, table or cursor range\&. \fP"
.ti -1c
.RI "int \fBupgrade\fP (\fBWT_SESSION\fP *session, const char *name, const char *config)"
.br
.RI "\fIUpgrade a file or table\&. \fP"
.ti -1c
.RI "int \fBverify\fP (\fBWT_SESSION\fP *session, const char *name, const char *config)"
.br
.RI "\fIVerify a file or table\&. \fP"
.in -1c
.in -1c
.PP
.RI "\fBTransactions\fP"
.br

.in +1c
.in +1c
.ti -1c
.RI "int \fBbegin_transaction\fP (\fBWT_SESSION\fP *session, const char *config)"
.br
.RI "\fIStart a transaction in this session\&. \fP"
.ti -1c
.RI "int \fBcommit_transaction\fP (\fBWT_SESSION\fP *session, const char *config)"
.br
.RI "\fICommit the current transaction\&. \fP"
.ti -1c
.RI "int \fBrollback_transaction\fP (\fBWT_SESSION\fP *session, const char *config)"
.br
.RI "\fIRoll back the current transaction\&. \fP"
.ti -1c
.RI "int \fBcheckpoint\fP (\fBWT_SESSION\fP *session, const char *config)"
.br
.RI "\fIWrite a transactionally consistent snapshot of a database or set of objects\&. \fP"
.ti -1c
.RI "int \fBtransaction_pinned_range\fP (\fBWT_SESSION\fP *session, uint64_t *range)"
.br
.RI "\fIReturn the transaction ID range pinned by the session handle\&. \fP"
.in -1c
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "\fBWT_CONNECTION\fP * \fBconnection\fP"
.br
.RI "\fIThe connection for this session\&. \fP"
.ti -1c
.RI "void * \fBapp_private\fP"
.br
.RI "\fIA location for applications to store information that will be available in callbacks taking a \fBWT_SESSION\fP handle\&. \fP"
.in -1c
.SH "Detailed Description"
.PP 
All data operations are performed in the context of a \fBWT_SESSION\fP\&. 

This encapsulates the thread and transactional context of the operation\&.
.PP
\fBThread safety:\fP A \fBWT_SESSION\fP handle is not usually shared between threads, see \fBMultithreading\fP for more information\&. 
.PP
\fBExamples: \fP
.in +1c
\fBex_access\&.c\fP, \fBex_async\&.c\fP, \fBex_call_center\&.c\fP, \fBex_config\&.c\fP, \fBex_cursor\&.c\fP, \fBex_extending\&.c\fP, \fBex_extractor\&.c\fP, \fBex_hello\&.c\fP, \fBex_log\&.c\fP, \fBex_pack\&.c\fP, \fBex_schema\&.c\fP, \fBex_stat\&.c\fP, and \fBex_thread\&.c\fP\&.
.SH "Member Function Documentation"
.PP 
.SS "int WT_SESSION::begin_transaction (\fBWT_SESSION\fP *session, const char *config)"

.PP
Start a transaction in this session\&. The transaction remains active until ended by \fBWT_SESSION::commit_transaction\fP or \fBWT_SESSION::rollback_transaction\fP\&. Operations performed on cursors capable of supporting transactional operations that are already open in this session, or which are opened before the transaction ends, will operate in the context of the transaction\&.
.PP
\fBWT_SESSION::begin_transaction\fP will fail if a transaction is already in progress in the session\&.
.PP
.PP
.nf
 /*
         * Cursors may be opened before or after the transaction begins, and in
         * either case, subsequent operations are included in the transaction\&.
         * Opening cursors before the transaction begins allows applications to
         * cache cursors and use them for multiple operations\&.
         */
        ret =
            session->open_cursor(session, "table:mytable", NULL, NULL, &cursor);
        ret = session->begin_transaction(session, NULL);

        cursor->set_key(cursor, "key");
        cursor->set_value(cursor, "value");
        switch (ret = cursor->update(cursor)) {
        case 0:                                 /* Update success */
                ret = session->commit_transaction(session, NULL);
                /*
                 * If commit_transaction succeeds, cursors remain positioned; if
                 * commit_transaction fails, the transaction was rolled-back and
                 * and all cursors are reset\&.
                 */
                break;
        case WT_ROLLBACK:                       /* Update conflict */
        default:                                /* Other error */
                ret = session->rollback_transaction(session, NULL);
                /* The rollback_transaction call resets all cursors\&. */
                break;
        }

        /*
         * Cursors remain open and may be used for multiple transactions\&.
         */
.fi
.PP
 
.PP
\fBParameters:\fP
.RS 4
\fIsession\fP the session handle 
.br
\fIconfig\fP Configuration string, see \fBConfiguration Strings\fP\&. Permitted values: NameEffectValues \fCisolation\fPthe isolation level for this transaction; defaults to the session's isolation level\&.a string, chosen from the following options: \fC'read-uncommitted'\fP, \fC'read-committed'\fP, \fC'snapshot'\fP; default empty\&. \fCname\fPname of the transaction for tracing and debugging\&.a string; default empty\&. \fCpriority\fPpriority of the transaction for resolving conflicts\&. Transactions with higher values are less likely to abort\&.an integer between -100 and 100; default \fC0\fP\&. \fCsync\fPwhether to sync log records when the transaction commits, inherited from \fBwiredtiger_open\fP \fCtransaction_sync\fP\&.a boolean flag; default empty\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
zero on success and a non-zero error code on failure\&. See \fBError Returns\fP for details\&. 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
\fBex_config\&.c\fP, and \fBex_log\&.c\fP\&.
.SS "int WT_SESSION::checkpoint (\fBWT_SESSION\fP *session, const char *config)"

.PP
Write a transactionally consistent snapshot of a database or set of objects\&. The checkpoint includes all transactions committed before the checkpoint starts\&. Additionally, checkpoints may optionally be discarded\&.
.PP
.PP
.nf
   /* Checkpoint the database\&. */
        ret = session->checkpoint(session, NULL);

        /* Checkpoint of the database, creating a named snapshot\&. */
        ret = session->checkpoint(session, "name=June01");

        /*
         * Checkpoint a list of objects\&.
         * JSON parsing requires quoting the list of target URIs\&.
         */
        ret = session->
            checkpoint(session, "target=(\"table:table1\",\"table:table2\")");

        /*
         * Checkpoint a list of objects, creating a named snapshot\&.
         * JSON parsing requires quoting the list of target URIs\&.
         */
        ret = session->
            checkpoint(session, "target=(\"table:mytable\"),name=midnight");

        /* Checkpoint the database, discarding all previous snapshots\&. */
        ret = session->checkpoint(session, "drop=(from=all)");

        /* Checkpoint the database, discarding the "midnight" snapshot\&. */
        ret = session->checkpoint(session, "drop=(midnight)");

        /*
         * Checkpoint the database, discarding all snapshots after and
         * including "noon"\&.
         */
        ret = session->checkpoint(session, "drop=(from=noon)");

        /*
         * Checkpoint the database, discarding all snapshots before and
         * including "midnight"\&.
         */
        ret = session->checkpoint(session, "drop=(to=midnight)");

        /*
         * Create a checkpoint of a table, creating the "July01" snapshot and
         * discarding the "May01" and "June01" snapshots\&.
         * JSON parsing requires quoting the list of target URIs\&.
         */
        ret = session->checkpoint(session,
            "target=(\"table:mytable\"),name=July01,drop=(May01,June01)");
.fi
.PP
 
.PP
\fBParameters:\fP
.RS 4
\fIsession\fP the session handle 
.br
\fIconfig\fP Configuration string, see \fBConfiguration Strings\fP\&. Permitted values: NameEffectValues \fCdrop\fPspecify a list of checkpoints to drop\&. The list may additionally contain one of the following keys: \fC'from=all'\fP to drop all checkpoints, \fC'from=<checkpoint>'\fP to drop all checkpoints after and including the named checkpoint, or \fC'to=<checkpoint>'\fP to drop all checkpoints before and including the named checkpoint\&. Checkpoints cannot be dropped while a hot backup is in progress or if open in a cursor\&.a list of strings; default empty\&. \fCforce\fPby default, checkpoints may be skipped if the underlying object has not been modified, this option forces the checkpoint\&.a boolean flag; default \fCfalse\fP\&. \fCname\fPif set, specify a name for the checkpoint (note that checkpoints including LSM trees may not be named)\&.a string; default empty\&. \fCtarget\fPif non-empty, checkpoint the list of objects\&.a list of strings; default empty\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
zero on success and a non-zero error code on failure\&. See \fBError Returns\fP for details\&. 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
\fBex_stat\&.c\fP\&.
.SS "int WT_SESSION::close (\fBWT_SESSION\fP *session, const char *config)"

.PP
Close the session handle\&. This will release the resources associated with the session handle, including rolling back any active transactions and closing any cursors that remain open in the session\&.
.PP
.PP
.nf
 ret = session->close(session, NULL);
.fi
.PP
 
.PP
\fBParameters:\fP
.RS 4
\fIsession\fP the session handle 
.br
\fIconfig\fP Configuration string, see \fBConfiguration Strings\fP\&. No values currently permitted\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
zero on success and a non-zero error code on failure\&. See \fBError Returns\fP for details\&. 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
\fBex_log\&.c\fP, and \fBex_thread\&.c\fP\&.
.SS "int WT_SESSION::commit_transaction (\fBWT_SESSION\fP *session, const char *config)"

.PP
Commit the current transaction\&. A transaction must be in progress when this method is called\&.
.PP
If \fBWT_SESSION::commit_transaction\fP returns an error, the transaction was rolled back, not committed\&.
.PP
.PP
.nf
   /*
         * Cursors may be opened before or after the transaction begins, and in
         * either case, subsequent operations are included in the transaction\&.
         * Opening cursors before the transaction begins allows applications to
         * cache cursors and use them for multiple operations\&.
         */
        ret =
            session->open_cursor(session, "table:mytable", NULL, NULL, &cursor);
        ret = session->begin_transaction(session