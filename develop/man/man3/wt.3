.TH "WiredTiger API" 3 "Sat Apr 11 2015" "Version Version 2.5.3" "WiredTiger" \" -*- nroff -*-
.ad l
.nh
.SH NAME
WiredTiger API \- 
.PP
The functions, handles and methods applications use to access and manage data with WiredTiger\&.  

.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBWT_ITEM\fP"
.br
.RI "\fIA raw item of data to be managed, including a pointer to the data and a length\&. \fP"
.ti -1c
.RI "struct \fBWT_LSN\fP"
.br
.RI "\fIA log sequence number, representing a position in the transaction log\&. \fP"
.ti -1c
.RI "struct \fBWT_CURSOR\fP"
.br
.RI "\fIA \fBWT_CURSOR\fP handle is the interface to a cursor\&. \fP"
.ti -1c
.RI "struct \fBWT_ASYNC_OP\fP"
.br
.RI "\fIA \fBWT_ASYNC_OP\fP handle is the interface to an asynchronous operation\&. \fP"
.ti -1c
.RI "struct \fBWT_SESSION\fP"
.br
.RI "\fIAll data operations are performed in the context of a \fBWT_SESSION\fP\&. \fP"
.ti -1c
.RI "struct \fBWT_CONNECTION\fP"
.br
.RI "\fIA connection to a WiredTiger database\&. \fP"
.ti -1c
.RI "struct \fBWT_ASYNC_CALLBACK\fP"
.br
.RI "\fIThe interface implemented by applications to accept notifications of the completion of asynchronous operations\&. \fP"
.ti -1c
.RI "struct \fBWT_EVENT_HANDLER\fP"
.br
.RI "\fIThe interface implemented by applications to handle error, informational and progress messages\&. \fP"
.ti -1c
.RI "struct \fBWT_CONFIG_ITEM\fP"
.br
.RI "\fIThe configuration information returned by the WiredTiger configuration parsing functions in the \fBWT_EXTENSION_API\fP and the public API\&. \fP"
.ti -1c
.RI "struct \fBWT_CONFIG_PARSER\fP"
.br
.RI "\fIA handle that can be used to search and traverse configuration strings compatible with WiredTiger APIs\&. \fP"
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBWT_INTPACK64_MAXSIZE\fP"
.br
.RI "\fIThe maximum packed size of a 64-bit integer\&. \fP"
.ti -1c
.RI "#define \fBWT_INTPACK32_MAXSIZE\fP"
.br
.RI "\fIThe maximum packed size of a 32-bit integer\&. \fP"
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBWT_ASYNC_OPTYPE\fP { \fBWT_AOP_NONE\fP, \fBWT_AOP_COMPACT\fP, \fBWT_AOP_INSERT\fP, \fBWT_AOP_REMOVE\fP, \fBWT_AOP_SEARCH\fP, \fBWT_AOP_UPDATE\fP }"
.br
.RI "\fIAsynchronous operation types\&. \fP"
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "int \fBwiredtiger_open\fP (const char *home, \fBWT_EVENT_HANDLER\fP *errhandler, const char *config, \fBWT_CONNECTION\fP **connectionp)"
.br
.RI "\fIOpen a connection to a database\&. \fP"
.ti -1c
.RI "const char * \fBwiredtiger_strerror\fP (int error)"
.br
.RI "\fIReturn information about a WiredTiger error as a string, not thread-safe\&. \fP"
.ti -1c
.RI "const char * \fBwiredtiger_version\fP (int *majorp, int *minorp, int *patchp)"
.br
.RI "\fIGet version information\&. \fP"
.in -1c
.SS "Data packing and unpacking"

.in +1c
.ti -1c
.RI "typedef struct __wt_pack_stream \fBWT_PACK_STREAM\fP"
.br
.RI "\fIStreaming interface to packing\&. \fP"
.ti -1c
.RI "int \fBwiredtiger_struct_pack\fP (\fBWT_SESSION\fP *session, void *buffer, size_t size, const char *format,\&.\&.\&.)"
.br
.RI "\fIPack a structure into a buffer\&. \fP"
.ti -1c
.RI "int \fBwiredtiger_struct_size\fP (\fBWT_SESSION\fP *session, size_t *sizep, const char *format,\&.\&.\&.)"
.br
.RI "\fICalculate the size required to pack a structure\&. \fP"
.ti -1c
.RI "int \fBwiredtiger_struct_unpack\fP (\fBWT_SESSION\fP *session, const void *buffer, size_t size, const char *format,\&.\&.\&.)"
.br
.RI "\fIUnpack a structure from a buffer\&. \fP"
.ti -1c
.RI "int \fBwiredtiger_pack_start\fP (\fBWT_SESSION\fP *session, const char *format, void *buffer, size_t size, \fBWT_PACK_STREAM\fP **psp)"
.br
.RI "\fIStart a packing operation into a buffer with the given format string\&. \fP"
.ti -1c
.RI "int \fBwiredtiger_unpack_start\fP (\fBWT_SESSION\fP *session, const char *format, const void *buffer, size_t size, \fBWT_PACK_STREAM\fP **psp)"
.br
.RI "\fIStart an unpacking operation from a buffer with the given format string\&. \fP"
.ti -1c
.RI "int \fBwiredtiger_pack_close\fP (\fBWT_PACK_STREAM\fP *ps, size_t *usedp)"
.br
.RI "\fIClose a packing stream\&. \fP"
.ti -1c
.RI "int \fBwiredtiger_pack_item\fP (\fBWT_PACK_STREAM\fP *ps, \fBWT_ITEM\fP *item)"
.br
.RI "\fIPack an item into a packing stream\&. \fP"
.ti -1c
.RI "int \fBwiredtiger_pack_int\fP (\fBWT_PACK_STREAM\fP *ps, int64_t i)"
.br
.RI "\fIPack a signed integer into a packing stream\&. \fP"
.ti -1c
.RI "int \fBwiredtiger_pack_str\fP (\fBWT_PACK_STREAM\fP *ps, const char *s)"
.br
.RI "\fIPack a string into a packing stream\&. \fP"
.ti -1c
.RI "int \fBwiredtiger_pack_uint\fP (\fBWT_PACK_STREAM\fP *ps, uint64_t u)"
.br
.RI "\fIPack an unsigned integer into a packing stream\&. \fP"
.ti -1c
.RI "int \fBwiredtiger_unpack_item\fP (\fBWT_PACK_STREAM\fP *ps, \fBWT_ITEM\fP *item)"
.br
.RI "\fIUnpack an item from a packing stream\&. \fP"
.ti -1c
.RI "int \fBwiredtiger_unpack_int\fP (\fBWT_PACK_STREAM\fP *ps, int64_t *ip)"
.br
.RI "\fIUnpack a signed integer from a packing stream\&. \fP"
.ti -1c
.RI "int \fBwiredtiger_unpack_str\fP (\fBWT_PACK_STREAM\fP *ps, const char **sp)"
.br
.RI "\fIUnpack a string from a packing stream\&. \fP"
.ti -1c
.RI "int \fBwiredtiger_unpack_uint\fP (\fBWT_PACK_STREAM\fP *ps, uint64_t *up)"
.br
.RI "\fIUnpack an unsigned integer from a packing stream\&. \fP"
.in -1c
.SS "Configuration string parsing"

.in +1c
.ti -1c
.RI "int \fBwiredtiger_config_parser_open\fP (\fBWT_SESSION\fP *session, const char *config, size_t len, \fBWT_CONFIG_PARSER\fP **config_parserp)"
.br
.RI "\fICreate a handle that can be used to parse or create configuration strings compatible with WiredTiger APIs\&. \fP"
.in -1c
.SS "Error returns"
 Most functions and methods in WiredTiger return an integer code indicating whether the operation succeeded or failed\&. A return of zero indicates success, all non-zero return values indicate some kind of failure\&.
.PP
WiredTiger reserves all values from -31,800 to -31,999 as possible error return values\&. WiredTiger may also return C99/POSIX error codes such as \fCENOMEM\fP, \fCEINVAL\fP and \fCENOTSUP\fP, with the usual meanings\&.
.PP
The following are all of the WiredTiger-specific error returns: 
.in +1c
.ti -1c
.RI "#define \fBWT_ROLLBACK\fP"
.br
.RI "\fIConflict between concurrent operations\&. \fP"
.ti -1c
.RI "#define \fBWT_DUPLICATE_KEY\fP"
.br
.RI "\fIAttempt to insert an existing key\&. \fP"
.ti -1c
.RI "#define \fBWT_ERROR\fP"
.br
.RI "\fINon-specific WiredTiger error\&. \fP"
.ti -1c
.RI "#define \fBWT_NOTFOUND\fP"
.br
.RI "\fIItem not found\&. \fP"
.ti -1c
.RI "#define \fBWT_PANIC\fP"
.br
.RI "\fIWiredTiger library panic\&. \fP"
.ti -1c
.RI "#define \fBWT_RUN_RECOVERY\fP"
.br
.RI "\fIRecovery must be run to continue\&. \fP"
.in -1c
.SS "Connection statistics"
Statistics are accessed through cursors with \fC'statistics:'\fP URIs\&. Individual statistics can be queried through the cursor using the following keys\&. See \fBStatistics Data\fP for more information\&. 
.in +1c
.ti -1c
.RI "#define \fBWT_STAT_CONN_ASYNC_ALLOC_RACE\fP"
.br
.RI "\fIasync: number of allocation state races \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_ASYNC_ALLOC_VIEW\fP"
.br
.RI "\fIasync: number of operation slots viewed for allocation \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_ASYNC_CUR_QUEUE\fP"
.br
.RI "\fIasync: current work queue length \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_ASYNC_FLUSH\fP"
.br
.RI "\fIasync: number of flush calls \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_ASYNC_FULL\fP"
.br
.RI "\fIasync: number of times operation allocation failed \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_ASYNC_MAX_QUEUE\fP"
.br
.RI "\fIasync: maximum work queue length \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_ASYNC_NOWORK\fP"
.br
.RI "\fIasync: number of times worker found no work \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_ASYNC_OP_ALLOC\fP"
.br
.RI "\fIasync: total allocations \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_ASYNC_OP_COMPACT\fP"
.br
.RI "\fIasync: total compact calls \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_ASYNC_OP_INSERT\fP"
.br
.RI "\fIasync: total insert calls \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_ASYNC_OP_REMOVE\fP"
.br
.RI "\fIasync: total remove calls \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_ASYNC_OP_SEARCH\fP"
.br
.RI "\fIasync: total search calls \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_ASYNC_OP_UPDATE\fP"
.br
.RI "\fIasync: total update calls \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_BLOCK_BYTE_MAP_READ\fP"
.br
.RI "\fIblock-manager: mapped bytes read \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_BLOCK_BYTE_READ\fP"
.br
.RI "\fIblock-manager: bytes read \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_BLOCK_BYTE_WRITE\fP"
.br
.RI "\fIblock-manager: bytes written \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_BLOCK_MAP_READ\fP"
.br
.RI "\fIblock-manager: mapped blocks read \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_BLOCK_PRELOAD\fP"
.br
.RI "\fIblock-manager: blocks pre-loaded \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_BLOCK_READ\fP"
.br
.RI "\fIblock-manager: blocks read \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_BLOCK_WRITE\fP"
.br
.RI "\fIblock-manager: blocks written \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_CACHE_BYTES_DIRTY\fP"
.br
.RI "\fIcache: tracked dirty bytes in the cache \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_CACHE_BYTES_INTERNAL\fP"
.br
.RI "\fIcache: tracked bytes belonging to internal pages in the cache \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_CACHE_BYTES_INUSE\fP"
.br
.RI "\fIcache: bytes currently in the cache \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_CACHE_BYTES_LEAF\fP"
.br
.RI "\fIcache: tracked bytes belonging to leaf pages in the cache \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_CACHE_BYTES_MAX\fP"
.br
.RI "\fIcache: maximum bytes configured \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_CACHE_BYTES_OVERFLOW\fP"
.br
.RI "\fIcache: tracked bytes belonging to overflow pages in the cache \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_CACHE_BYTES_READ\fP"
.br
.RI "\fIcache: bytes read into cache \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_CACHE_BYTES_WRITE\fP"
.br
.RI "\fIcache: bytes written from cache \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_CACHE_EVICTION_APP\fP"
.br
.RI "\fIcache: pages evicted by application threads \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_CACHE_EVICTION_CHECKPOINT\fP"
.br
.RI "\fIcache: checkpoint blocked page eviction \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_CACHE_EVICTION_CLEAN\fP"
.br
.RI "\fIcache: unmodified pages evicted \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_CACHE_EVICTION_DEEPEN\fP"
.br
.RI "\fIcache: page split during eviction deepened the tree \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_CACHE_EVICTION_DIRTY\fP"
.br
.RI "\fIcache: modified pages evicted \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_CACHE_EVICTION_FAIL\fP"
.br
.RI "\fIcache: pages selected for eviction unable to be evicted \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_CACHE_EVICTION_FORCE\fP"
.br
.RI "\fIcache: pages evicted because they exceeded the in-memory maximum \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_CACHE_EVICTION_FORCE_DELETE\fP"
.br
.RI "\fIcache: pages evicted because they had chains of deleted items \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_CACHE_EVICTION_FORCE_FAIL\fP"
.br
.RI "\fIcache: failed eviction of pages that exceeded the in-memory maximum \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_CACHE_EVICTION_HAZARD\fP"
.br
.RI "\fIcache: hazard pointer blocked page eviction \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_CACHE_EVICTION_INTERNAL\fP"
.br
.RI "\fIcache: internal pages evicted \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_CACHE_EVICTION_MAXIMUM_PAGE_SIZE\fP"
.br
.RI "\fIcache: maximum page size at eviction \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_CACHE_EVICTION_QUEUE_EMPTY\fP"
.br
.RI "\fIcache: eviction server candidate queue empty when topping up \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_CACHE_EVICTION_QUEUE_NOT_EMPTY\fP"
.br
.RI "\fIcache: eviction server candidate queue not empty when topping up \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_CACHE_EVICTION_SERVER_EVICTING\fP"
.br
.RI "\fIcache: eviction server evicting pages \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_CACHE_EVICTION_SERVER_NOT_EVICTING\fP"
.br
.RI "\fIcache: eviction server populating queue, but not evicting pages \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_CACHE_EVICTION_SLOW\fP"
.br
.RI "\fIcache: eviction server unable to reach eviction goal \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_CACHE_EVICTION_SPLIT\fP"
.br
.RI "\fIcache: pages split during eviction \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_CACHE_EVICTION_WALK\fP"
.br
.RI "\fIcache: pages walked for eviction \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_CACHE_EVICTION_WORKER_EVICTING\fP"
.br
.RI "\fIcache: eviction worker thread evicting pages \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_CACHE_INMEM_SPLIT\fP"
.br
.RI "\fIcache: in-memory page splits \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_CACHE_OVERHEAD\fP"
.br
.RI "\fIcache: percentage overhead \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_CACHE_PAGES_DIRTY\fP"
.br
.RI "\fIcache: tracked dirty pages in the cache \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_CACHE_PAGES_INUSE\fP"
.br
.RI "\fIcache: pages currently held in the cache \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_CACHE_READ\fP"
.br
.RI "\fIcache: pages read into cache \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_CACHE_WRITE\fP"
.br
.RI "\fIcache: pages written from cache \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_COND_WAIT\fP"
.br
.RI "\fIconnection: pthread mutex condition wait calls \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_CURSOR_CREATE\fP"
.br
.RI "\fIcursor: cursor create calls \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_CURSOR_INSERT\fP"
.br
.RI "\fIcursor: cursor insert calls \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_CURSOR_NEXT\fP"
.br
.RI "\fIcursor: cursor next calls \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_CURSOR_PREV\fP"
.br
.RI "\fIcursor: cursor prev calls \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_CURSOR_REMOVE\fP"
.br
.RI "\fIcursor: cursor remove calls \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_CURSOR_RESET\fP"
.br
.RI "\fIcursor: cursor reset calls \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_CURSOR_SEARCH\fP"
.br
.RI "\fIcursor: cursor search calls \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_CURSOR_SEARCH_NEAR\fP"
.br
.RI "\fIcursor: cursor search near calls \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_CURSOR_UPDATE\fP"
.br
.RI "\fIcursor: cursor update calls \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_DH_CONN_HANDLES\fP"
.br
.RI "\fIdata-handle: connection dhandles swept \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_DH_CONN_REF\fP"
.br
.RI "\fIdata-handle: connection candidate referenced \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_DH_CONN_SWEEPS\fP"
.br
.RI "\fIdata-handle: connection sweeps \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_DH_CONN_TOD\fP"
.br
.RI "\fIdata-handle: connection time-of-death sets \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_DH_SESSION_HANDLES\fP"
.br
.RI "\fIdata-handle: session dhandles swept \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_DH_SESSION_SWEEPS\fP"
.br
.RI "\fIdata-handle: session sweep attempts \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_FILE_OPEN\fP"
.br
.RI "\fIconnection: files currently open \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_LOG_BUFFER_GROW\fP"
.br
.RI "\fIlog: log buffer size increases \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_LOG_BUFFER_SIZE\fP"
.br
.RI "\fIlog: total log buffer size \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_LOG_BYTES_PAYLOAD\fP"
.br
.RI "\fIlog: log bytes of payload data \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_LOG_BYTES_WRITTEN\fP"
.br
.RI "\fIlog: log bytes written \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_LOG_CLOSE_YIELDS\fP"
.br
.RI "\fIlog: yields waiting for previous log file close \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_LOG_COMPRESS_LEN\fP"
.br
.RI "\fIlog: total size of compressed records \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_LOG_COMPRESS_MEM\fP"
.br
.RI "\fIlog: total in-memory size of compressed records \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_LOG_COMPRESS_SMALL\fP"
.br
.RI "\fIlog: log records too small to compress \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_LOG_COMPRESS_WRITE_FAILS\fP"
.br
.RI "\fIlog: log records not compressed \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_LOG_COMPRESS_WRITES\fP"
.br
.RI "\fIlog: log records compressed \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_LOG_MAX_FILESIZE\fP"
.br
.RI "\fIlog: maximum log file size \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_LOG_PREALLOC_FILES\fP"
.br
.RI "\fIlog: pre-allocated log files prepared \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_LOG_PREALLOC_MAX\fP"
.br
.RI "\fIlog: number of pre-allocated log files to create \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_LOG_PREALLOC_USED\fP"
.br
.RI "\fIlog: pre-allocated log files used \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_LOG_READS\fP"
.br
.RI "\fIlog: log read operations \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_LOG_RELEASE_WRITE_LSN\fP"
.br
.RI "\fIlog: log release advances write LSN \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_LOG_SCAN_RECORDS\fP"
.br
.RI "\fIlog: records processed by log scan \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_LOG_SCAN_REREADS\fP"
.br
.RI "\fIlog: log scan records requiring two reads \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_LOG_SCANS\fP"
.br
.RI "\fIlog: log scan operations \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_LOG_SLOT_CLOSES\fP"
.br
.RI "\fIlog: consolidated slot closures \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_LOG_SLOT_CONSOLIDATED\fP"
.br
.RI "\fIlog: logging bytes consolidated \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_LOG_SLOT_JOINS\fP"
.br
.RI "\fIlog: consolidated slot joins \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_LOG_SLOT_RACES\fP"
.br
.RI "\fIlog: consolidated slot join races \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_LOG_SLOT_SWITCH_FAILS\fP"
.br
.RI "\fIlog: slots selected for switching that were unavailable \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_LOG_SLOT_TOOBIG\fP"
.br
.RI "\fIlog: record size exceeded maximum \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_LOG_SLOT_TOOSMALL\fP"
.br
.RI "\fIlog: failed to find a slot large enough for record \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_LOG_SLOT_TRANSITIONS\fP"
.br
.RI "\fIlog: consolidated slot join transitions \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_LOG_SYNC\fP"
.br
.RI "\fIlog: log sync operations \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_LOG_SYNC_DIR\fP"
.br
.RI "\fIlog: log sync_dir operations \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_LOG_WRITE_LSN\fP"
.br
.RI "\fIlog: log server thread advances write LSN \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_LOG_WRITES\fP"
.br
.RI "\fIlog: log write operations \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_LSM_CHECKPOINT_THROTTLE\fP"
.br
.RI "\fILSM: sleep for LSM checkpoint throttle\&. \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_LSM_MERGE_THROTTLE\fP"
.br
.RI "\fILSM: sleep for LSM merge throttle\&. \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_LSM_ROWS_MERGED\fP"
.br
.RI "\fILSM: rows merged in an LSM tree\&. \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_LSM_WORK_QUEUE_APP\fP"
.br
.RI "\fILSM: application work units currently queued\&. \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_LSM_WORK_QUEUE_MANAGER\fP"
.br
.RI "\fILSM: merge work units currently queued\&. \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_LSM_WORK_QUEUE_MAX\fP"
.br
.RI "\fILSM: tree queue hit maximum\&. \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_LSM_WORK_QUEUE_SWITCH\fP"
.br
.RI "\fILSM: switch work units currently queued\&. \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_LSM_WORK_UNITS_CREATED\fP"
.br
.RI "\fILSM: tree maintenance operations scheduled\&. \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_LSM_WORK_UNITS_DISCARDED\fP"
.br
.RI "\fILSM: tree maintenance operations discarded\&. \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_LSM_WORK_UNITS_DONE\fP"
.br
.RI "\fILSM: tree maintenance operations executed\&. \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_MEMORY_ALLOCATION\fP"
.br
.RI "\fIconnection: memory allocations \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_MEMORY_FREE\fP"
.br
.RI "\fIconnection: memory frees \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_MEMORY_GROW\fP"
.br
.RI "\fIconnection: memory re-allocations \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_PAGE_BUSY_BLOCKED\fP"
.br
.RI "\fIthread-yield: page acquire busy blocked \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_PAGE_FORCIBLE_EVICT_BLOCKED\fP"
.br
.RI "\fIthread-yield: page acquire eviction blocked \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_PAGE_LOCKED_BLOCKED\fP"
.br
.RI "\fIthread-yield: page acquire locked blocked \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_PAGE_READ_BLOCKED\fP"
.br
.RI "\fIthread-yield: page acquire read blocked \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_PAGE_SLEEP\fP"
.br
.RI "\fIthread-yield: page acquire time sleeping (usecs) \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_READ_IO\fP"
.br
.RI "\fIconnection: total read I/Os \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_REC_PAGES\fP"
.br
.RI "\fIreconciliation: page reconciliation calls \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_REC_PAGES_EVICTION\fP"
.br
.RI "\fIreconciliation: page reconciliation calls for eviction \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_REC_SPLIT_STASHED_BYTES\fP"
.br
.RI "\fIreconciliation: split bytes currently awaiting free \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_REC_SPLIT_STASHED_OBJECTS\fP"
.br
.RI "\fIreconciliation: split objects currently awaiting free \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_RWLOCK_READ\fP"
.br
.RI "\fIconnection: pthread mutex shared lock read-lock calls \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_RWLOCK_WRITE\fP"
.br
.RI "\fIconnection: pthread mutex shared lock write-lock calls \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_SESSION_CURSOR_OPEN\fP"
.br
.RI "\fIsession: open cursor count \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_SESSION_OPEN\fP"
.br
.RI "\fIsession: open session count \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_TXN_BEGIN\fP"
.br
.RI "\fItransaction: transaction begins \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_TXN_CHECKPOINT\fP"
.br
.RI "\fItransaction: transaction checkpoints \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_TXN_CHECKPOINT_GENERATION\fP"
.br
.RI "\fItransaction: transaction checkpoint generation \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_TXN_CHECKPOINT_RUNNING\fP"
.br
.RI "\fItransaction: transaction checkpoint currently running \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_TXN_CHECKPOINT_TIME_MAX\fP"
.br
.RI "\fItransaction: transaction checkpoint max time (msecs) \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_TXN_CHECKPOINT_TIME_MIN\fP"
.br
.RI "\fItransaction: transaction checkpoint min time (msecs) \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_TXN_CHECKPOINT_TIME_RECENT\fP"
.br
.RI "\fItransaction: transaction checkpoint most recent time (msecs) \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_TXN_CHECKPOINT_TIME_TOTAL\fP"
.br
.RI "\fItransaction: transaction checkpoint total time (msecs) \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_TXN_COMMIT\fP"
.br
.RI "\fItransaction: transactions committed \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_TXN_FAIL_CACHE\fP"
.br
.RI "\fItransaction: transaction failures due to cache overflow \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_TXN_PINNED_CHECKPOINT_RANGE\fP"
.br
.RI "\fItransaction: transaction range of IDs currently pinned by a checkpoint \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_TXN_PINNED_RANGE\fP"
.br
.RI "\fItransaction: transaction range of IDs currently pinned \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_TXN_ROLLBACK\fP"
.br
.RI "\fItransaction: transactions rolled back \fP"
.ti -1c
.RI "#define \fBWT_STAT_CONN_WRITE_IO\fP"
.br
.RI "\fIconnection: total write I/Os \fP"
.in -1c
.SS "Statistics for data sources"

.in +1c
.ti -1c
.RI "#define \fBWT_STAT_DSRC_ALLOCATION_SIZE\fP"
.br
.RI "\fIblock-manager: file allocation unit size \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_BLOCK_ALLOC\fP"
.br
.RI "\fIblock-manager: blocks allocated \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_BLOCK_CHECKPOINT_SIZE\fP"
.br
.RI "\fIblock-manager: checkpoint size \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_BLOCK_EXTENSION\fP"
.br
.RI "\fIblock-manager: allocations requiring file extension \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_BLOCK_FREE\fP"
.br
.RI "\fIblock-manager: blocks freed \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_BLOCK_MAGIC\fP"
.br
.RI "\fIblock-manager: file magic number \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_BLOCK_MAJOR\fP"
.br
.RI "\fIblock-manager: file major version number \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_BLOCK_MINOR\fP"
.br
.RI "\fIblock-manager: minor version number \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_BLOCK_REUSE_BYTES\fP"
.br
.RI "\fIblock-manager: file bytes available for reuse \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_BLOCK_SIZE\fP"
.br
.RI "\fIblock-manager: file size in bytes \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_BLOOM_COUNT\fP"
.br
.RI "\fILSM: bloom filters in the LSM tree\&. \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_BLOOM_FALSE_POSITIVE\fP"
.br
.RI "\fILSM: bloom filter false positives\&. \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_BLOOM_HIT\fP"
.br
.RI "\fILSM: bloom filter hits\&. \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_BLOOM_MISS\fP"
.br
.RI "\fILSM: bloom filter misses\&. \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_BLOOM_PAGE_EVICT\fP"
.br
.RI "\fILSM: bloom filter pages evicted from cache\&. \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_BLOOM_PAGE_READ\fP"
.br
.RI "\fILSM: bloom filter pages read into cache\&. \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_BLOOM_SIZE\fP"
.br
.RI "\fILSM: total size of bloom filters\&. \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_BTREE_CHECKPOINT_GENERATION\fP"
.br
.RI "\fIbtree: btree checkpoint generation \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_BTREE_COLUMN_DELETED\fP"
.br
.RI "\fIbtree: column-store variable-size deleted values \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_BTREE_COLUMN_FIX\fP"
.br
.RI "\fIbtree: column-store fixed-size leaf pages \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_BTREE_COLUMN_INTERNAL\fP"
.br
.RI "\fIbtree: column-store internal pages \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_BTREE_COLUMN_VARIABLE\fP"
.br
.RI "\fIbtree: column-store variable-size leaf pages \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_BTREE_COMPACT_REWRITE\fP"
.br
.RI "\fIbtree: pages rewritten by compaction \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_BTREE_ENTRIES\fP"
.br
.RI "\fIbtree: number of key/value pairs \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_BTREE_FIXED_LEN\fP"
.br
.RI "\fIbtree: fixed-record size \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_BTREE_MAXIMUM_DEPTH\fP"
.br
.RI "\fIbtree: maximum tree depth \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_BTREE_MAXINTLKEY\fP"
.br
.RI "\fIbtree: maximum internal page key size \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_BTREE_MAXINTLPAGE\fP"
.br
.RI "\fIbtree: maximum internal page size \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_BTREE_MAXLEAFKEY\fP"
.br
.RI "\fIbtree: maximum leaf page key size \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_BTREE_MAXLEAFPAGE\fP"
.br
.RI "\fIbtree: maximum leaf page size \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_BTREE_MAXLEAFVALUE\fP"
.br
.RI "\fIbtree: maximum leaf page value size \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_BTREE_OVERFLOW\fP"
.br
.RI "\fIbtree: overflow pages \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_BTREE_ROW_INTERNAL\fP"
.br
.RI "\fIbtree: row-store internal pages \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_BTREE_ROW_LEAF\fP"
.br
.RI "\fIbtree: row-store leaf pages \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_CACHE_BYTES_READ\fP"
.br
.RI "\fIcache: bytes read into cache \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_CACHE_BYTES_WRITE\fP"
.br
.RI "\fIcache: bytes written from cache \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_CACHE_EVICTION_CHECKPOINT\fP"
.br
.RI "\fIcache: checkpoint blocked page eviction \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_CACHE_EVICTION_CLEAN\fP"
.br
.RI "\fIcache: unmodified pages evicted \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_CACHE_EVICTION_DEEPEN\fP"
.br
.RI "\fIcache: page split during eviction deepened the tree \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_CACHE_EVICTION_DIRTY\fP"
.br
.RI "\fIcache: modified pages evicted \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_CACHE_EVICTION_FAIL\fP"
.br
.RI "\fIcache: data source pages selected for eviction unable to be evicted \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_CACHE_EVICTION_HAZARD\fP"
.br
.RI "\fIcache: hazard pointer blocked page eviction \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_CACHE_EVICTION_INTERNAL\fP"
.br
.RI "\fIcache: internal pages evicted \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_CACHE_EVICTION_SPLIT\fP"
.br
.RI "\fIcache: pages split during eviction \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_CACHE_INMEM_SPLIT\fP"
.br
.RI "\fIcache: in-memory page splits \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_CACHE_OVERFLOW_VALUE\fP"
.br
.RI "\fIcache: overflow values cached in memory \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_CACHE_READ\fP"
.br
.RI "\fIcache: pages read into cache \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_CACHE_READ_OVERFLOW\fP"
.br
.RI "\fIcache: overflow pages read into cache \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_CACHE_WRITE\fP"
.br
.RI "\fIcache: pages written from cache \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_COMPRESS_RAW_FAIL\fP"
.br
.RI "\fIcompression: raw compression call failed, no additional data available \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_COMPRESS_RAW_FAIL_TEMPORARY\fP"
.br
.RI "\fIcompression: raw compression call failed, additional data available \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_COMPRESS_RAW_OK\fP"
.br
.RI "\fIcompression: raw compression call succeeded \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_COMPRESS_READ\fP"
.br
.RI "\fIcompression: compressed pages read \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_COMPRESS_WRITE\fP"
.br
.RI "\fIcompression: compressed pages written \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_COMPRESS_WRITE_FAIL\fP"
.br
.RI "\fIcompression: page written failed to compress \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_COMPRESS_WRITE_TOO_SMALL\fP"
.br
.RI "\fIcompression: page written was too small to compress \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_CURSOR_CREATE\fP"
.br
.RI "\fIcursor: create calls \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_CURSOR_INSERT\fP"
.br
.RI "\fIcursor: insert calls \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_CURSOR_INSERT_BULK\fP"
.br
.RI "\fIcursor: bulk-loaded cursor-insert calls \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_CURSOR_INSERT_BYTES\fP"
.br
.RI "\fIcursor: cursor-insert key and value bytes inserted \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_CURSOR_NEXT\fP"
.br
.RI "\fIcursor: next calls \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_CURSOR_PREV\fP"
.br
.RI "\fIcursor: prev calls \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_CURSOR_REMOVE\fP"
.br
.RI "\fIcursor: remove calls \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_CURSOR_REMOVE_BYTES\fP"
.br
.RI "\fIcursor: cursor-remove key bytes removed \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_CURSOR_RESET\fP"
.br
.RI "\fIcursor: reset calls \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_CURSOR_SEARCH\fP"
.br
.RI "\fIcursor: search calls \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_CURSOR_SEARCH_NEAR\fP"
.br
.RI "\fIcursor: search near calls \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_CURSOR_UPDATE\fP"
.br
.RI "\fIcursor: update calls \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_CURSOR_UPDATE_BYTES\fP"
.br
.RI "\fIcursor: cursor-update value bytes updated \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_LSM_CHECKPOINT_THROTTLE\fP"
.br
.RI "\fILSM: sleep for LSM checkpoint throttle\&. \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_LSM_CHUNK_COUNT\fP"
.br
.RI "\fILSM: chunks in the LSM tree\&. \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_LSM_GENERATION_MAX\fP"
.br
.RI "\fILSM: highest merge generation in the LSM tree\&. \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_LSM_LOOKUP_NO_BLOOM\fP"
.br
.RI "\fILSM: queries that could have benefited from a Bloom filter that did not exist\&. \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_LSM_MERGE_THROTTLE\fP"
.br
.RI "\fILSM: sleep for LSM merge throttle\&. \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_REC_DICTIONARY\fP"
.br
.RI "\fIreconciliation: dictionary matches \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_REC_MULTIBLOCK_INTERNAL\fP"
.br
.RI "\fIreconciliation: internal page multi-block writes \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_REC_MULTIBLOCK_LEAF\fP"
.br
.RI "\fIreconciliation: leaf page multi-block writes \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_REC_MULTIBLOCK_MAX\fP"
.br
.RI "\fIreconciliation: maximum blocks required for a page \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_REC_OVERFLOW_KEY_INTERNAL\fP"
.br
.RI "\fIreconciliation: internal-page overflow keys \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_REC_OVERFLOW_KEY_LEAF\fP"
.br
.RI "\fIreconciliation: leaf-page overflow keys \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_REC_OVERFLOW_VALUE\fP"
.br
.RI "\fIreconciliation: overflow values written \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_REC_PAGE_DELETE\fP"
.br
.RI "\fIreconciliation: pages deleted \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_REC_PAGE_MATCH\fP"
.br
.RI "\fIreconciliation: page checksum matches \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_REC_PAGES\fP"
.br
.RI "\fIreconciliation: page reconciliation calls \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_REC_PAGES_EVICTION\fP"
.br
.RI "\fIreconciliation: page reconciliation calls for eviction \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_REC_PREFIX_COMPRESSION\fP"
.br
.RI "\fIreconciliation: leaf page key bytes discarded using prefix compression \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_REC_SUFFIX_COMPRESSION\fP"
.br
.RI "\fIreconciliation: internal page key bytes discarded using suffix compression \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_SESSION_COMPACT\fP"
.br
.RI "\fIsession: object compaction \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_SESSION_CURSOR_OPEN\fP"
.br
.RI "\fIsession: open cursor count \fP"
.ti -1c
.RI "#define \fBWT_STAT_DSRC_TXN_UPDATE_CONFLICT\fP"
.br
.RI "\fItransaction: update conflicts \fP"
.in -1c
.SS "Log record and operation types"

.in +1c
.ti -1c
.RI "#define \fBWT_LOGOP_INVALID\fP"
.br
.RI "\fIinvalid operation \fP"
.ti -1c
.RI "#define \fBWT_LOGREC_CHECKPOINT\fP"
.br
.RI "\fIcheckpoint \fP"
.ti -1c
.RI "#define \fBWT_LOGREC_COMMIT\fP"
.br
.RI "\fItransaction commit \fP"
.ti -1c
.RI "#define \fBWT_LOGREC_FILE_SYNC\fP"
.br
.RI "\fIfile sync \fP"
.ti -1c
.RI "#define \fBWT_LOGREC_MESSAGE\fP"
.br
.RI "\fImessage \fP"
.ti -1c
.RI "#define \fBWT_LOGOP_COL_PUT\fP"
.br
.RI "\fIcolumn put \fP"
.ti -1c
.RI "#define \fBWT_LOGOP_COL_REMOVE\fP"
.br
.RI "\fIcolumn remove \fP"
.ti -1c
.RI "#define \fBWT_LOGOP_COL_TRUNCATE\fP"
.br
.RI "\fIcolumn truncate \fP"
.ti -1c
.RI "#define \fBWT_LOGOP_ROW_PUT\fP"
.br
.RI "\fIrow put \fP"
.ti -1c
.RI "#define \fBWT_LOGOP_ROW_REMOVE\fP"
.br
.RI "\fIrow remove \fP"
.ti -1c
.RI "#define \fBWT_LOGOP_ROW_TRUNCATE\fP"
.br
.RI "\fIrow truncate \fP"
.in -1c
.SH "Detailed Description"
.PP 
The functions, handles and methods applications use to access and manage data with WiredTiger\&. 


.SH "Class Documentation"
.PP 
.SH "struct WT_ITEM"
.PP 
A raw item of data to be managed, including a pointer to the data and a length\&. 

\fBWT_ITEM\fP structures do not need to be cleared before use\&. 
.PP
\fBExamples: \fP
.in +1c
\fBex_async\&.c\fP, \fBex_extending\&.c\fP, \fBex_extractor\&.c\fP, \fBex_log\&.c\fP, and \fBex_schema\&.c\fP\&.
.PP
\fBClass Members:\fP
.RS 4
const void * \fIdata\fP The memory reference of the data item\&. For items returned by a \fBWT_CURSOR\fP, the pointer is only valid until the next operation on that cursor\&. Applications that need to keep an item across multiple cursor operations must make a copy\&. 
.br
.PP
size_t \fIsize\fP The number of bytes in the data item\&. The maximum length of a single column stored in a table is not fixed (as it partially depends on the underlying file configuration), but is always a small number of bytes less than 4GB\&. 
.br
.PP
.RE
.PP
.SH "struct WT_LSN"
.PP 
A log sequence number, representing a position in the transaction log\&. 
.PP
\fBExamples: \fP
.in +1c
\fBex_log\&.c\fP\&.
.PP
\fBClass Members:\fP
.RS 4
uint32_t \fIfile\fP Log file number\&. 
.br
.PP
wt_off_t \fIoffset\fP Log file offset\&. 
.br
.PP
.RE
.PP
.SH "struct WT_CONFIG_ITEM"
.PP 
The configuration information returned by the WiredTiger configuration parsing functions in the \fBWT_EXTENSION_API\fP and the public API\&. 
.PP
\fBClass Members:\fP
.RS 4
 \fI__unnamed__\fP Permitted values of the \fCtype\fP field\&. 
.br
.PP
.RE
.PP
\fBClass Members:\fP
.RS 4
size_t \fIlen\fP The number of bytes in the value referenced by \fCstr\fP\&. 
.br
.PP
const char * \fIstr\fP The value of a configuration string\&. Regardless of the type of the configuration string (boolean, int, list or string), the \fCstr\fP field will reference the value of the configuration string\&.
.PP
The bytes referenced by \fCstr\fP are \fBnot\fP nul-terminated, use the \fClen\fP field instead of a terminating nul byte\&. 
.br
.PP
enum \fBWT_CONFIG_ITEM\fP \fItype\fP Permitted values of the \fCtype\fP field\&. The type of value determined by the parser\&. In all cases, the \fCstr\fP and \fClen\fP fields are set\&. 
.br
.PP
int64_t \fIval\fP The numeric value of a configuration boolean or integer\&. If the configuration string's value is 'true' or 'false', the \fCval\fP field will be set to 1 (true), or 0 (false)\&.
.PP
If the configuration string can be legally interpreted as an integer, using the strtoll function rules as specified in ISO/IEC 9899:1990 ('ISO C90'), that integer will be stored in the \fCval\fP field\&. 
.br
.PP
.RE
.PP
.SH "Macro Definition Documentation"
.PP 
.SS "#define WT_DUPLICATE_KEY"

.PP
Attempt to insert an existing key\&. This error is generated when the application attempts to insert a record with the same key as an existing record without the 'overwrite' configuration to \fBWT_SESSION::open_cursor\fP\&. 
.SS "#define WT_ERROR"

.PP
Non-specific WiredTiger error\&. This error is returned when an error is not covered by a specific error return\&. 
.SS "#define WT_INTPACK32_MAXSIZE"

.PP
The maximum packed size of a 32-bit integer\&. The \fBwiredtiger_struct_pack\fP function will pack single integers into at most this many bytes\&. 
.SS "#define WT_INTPACK64_MAXSIZE"

.PP
The maximum packed size of a 64-bit integer\&. The \fBwiredtiger_struct_pack\fP function will pack single long integers into at most this many bytes\&. 
.SS "#define WT_NOTFOUND"

.PP
Item not found\&. This error indicates an operation did not find a value to return\&. This includes cursor search and other operations where no record matched the cursor's search key such as \fBWT_CURSOR::update\fP or \fBWT_CURSOR::remove\fP\&. 
.PP
\fBExamples: \fP
.in +1c
\fBex_log\&.c\fP, \fBex_stat\&.c\fP, and \fBex_thread\&.c\fP\&.
.SS "#define WT_PANIC"

.PP
WiredTiger library panic\&. This error indicates an underlying problem that requires the application exit and restart\&. The application can exit immediately when \fCWT_PANIC\fP is returned from a WiredTiger interface, no further WiredTiger calls are required\&. 
.SS "#define WT_ROLLBACK"

.PP
Conflict between concurrent operations\&. This error is generated when an operation cannot be completed due to a conflict with concurrent operations\&. The operation may be retried; if a transaction is in progress, it should be rolled back and the operation retried in a new transaction\&. 
.SS "#define WT_RUN_RECOVERY"

.PP
Recovery must be run to continue\&. This error is generated when wiredtiger_open is configured to return an error if recovery is required to use the database\&. 
.SH "Typedef Documentation"
.PP 
.SS "typedef struct __wt_pack_stream \fBWT_PACK_STREAM\fP"

.PP
Streaming interface to packing\&. This allows applications to pack or unpack records one field at a time\&. This is an opaque handle returned by \fBwiredtiger_pack_start\fP or \fBwiredtiger_unpack_start\fP\&. It must be closed with \fBwiredtiger_pack_close\fP\&. 
.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBWT_ASYNC_OPTYPE\fP"

.PP
Asynchronous operation types\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIWT_AOP_NONE \fP\fP
No operation type set\&. 
.TP
\fB\fIWT_AOP_COMPACT \fP\fP
\fBWT_ASYNC_OP::compact\fP\&. 
.TP
\fB\fIWT_AOP_INSERT \fP\fP
\fBWT_ASYNC_OP::insert\fP\&. 
.TP
\fB\fIWT_AOP_REMOVE \fP\fP
\fBWT_ASYNC_OP::remove\fP\&. 
.TP
\fB\fIWT_AOP_SEARCH \fP\fP
\fBWT_ASYNC_OP::search\fP\&. 
.TP
\fB\fIWT_AOP_UPDATE \fP\fP
\fBWT_ASYNC_OP::update\fP\&. 
.SH "Function Documentation"
.PP 
.SS "int wiredtiger_config_parser_open (\fBWT_SESSION\fP *session, const char *config, size_tlen, \fBWT_CONFIG_PARSER\fP **config_parserp)"

.PP
Create a handle that can be used to parse or create configuration strings compatible with WiredTiger APIs\&. This API is outside the scope of a WiredTiger connection handle, since applications may need to generate configuration strings prior to calling \fBwiredtiger_open\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIsession\fP the session handle to be used for error reporting (if NULL, error messages will be written to stderr)\&. 
.br
\fIconfig\fP the configuration string being parsed\&. The string must remain valid for the lifetime of the parser handle\&. 
.br
\fIlen\fP the number of valid bytes in \fCconfig\fP 
.br
\fIconfig_parserp\fP A pointer to the newly opened handle 
.RE
.PP
\fBReturns:\fP
.RS 4
zero on success and a non-zero error code on failure\&. See \fBError Returns\fP for details\&. 
.RE
.PP

.SS "int wiredtiger_open (const char *home, \fBWT_EVENT_HANDLER\fP *errhandler, const char *config, \fBWT_CONNECTION\fP **connectionp)"

.PP
Open a connection to a database\&. 
.PP
.nf
    ret = wiredtiger_open(home, NULL, "create,cache_size=500M", &conn);

.fi
.PP
 
.PP
\fBParameters:\fP
.RS 4
\fIhome\fP The path to the database home directory\&. See \fBDatabase Home Directory\fP for more information\&. 
.br
\fIerrhandler\fP An error handler\&. If \fCNULL\fP, a builtin error handler is installed that writes error messages to stderr 
.br
\fIconfig\fP Configuration string, see \fBConfiguration Strings\fP\&. Permitted values: NameEffectValues \fCasync = (\fPasynchronous operations configuration options\&.a set of related configuration options defined below\&. \fC    enabled\fPenable asynchronous operation\&.a boolean flag; default \fCfalse\fP\&. \fC    ops_max\fPmaximum number of expected simultaneous asynchronous operations\&.an integer between 1 and 4096; default \fC1024\fP\&. \fC    threads\fPthe number of worker threads to service asynchronous requests\&.an integer between 1 and 20; default \fC2\fP\&. \fC )\fP\fCbuffer_alignment\fPin-memory alignment (in bytes) for buffers used for I/O\&. The default value of -1 indicates a platform-specific alignment value should be used (4KB on Linux systems when direct I/O is configured, zero elsewhere)\&.an integer between -1 and 1MB; default \fC-1\fP\&. \fCcache_overhead\fPassume the heap allocator overhead is the specified percentage, and adjust the cache usage by that amount (for example, if there is 10GB of data in cache, a percentage of 10 means WiredTiger treats this as 11GB)\&. This value is configurable because different heap allocators have different overhead and different workloads will have different heap allocation sizes and patterns, therefore applications may need to adjust this value based on allocator choice and behavior in measured workloads\&.an integer between 0 and 30; default \fC8\fP\&. \fCcache_size\fPmaximum heap memory to allocate for the cache\&. A database should configure either \fCcache_size\fP or \fCshared_cache\fP but not both\&.an integer between 1MB and 10TB; default \fC100MB\fP\&. \fCcheckpoint = (\fPperiodically checkpoint the database\&.a set of related configuration options defined below\&. \fC    log_size\fPwait for this amount of log record bytes to be written to the log between each checkpoint\&. A database can configure both log_size and wait to set an upper bound for checkpoints; setting this value above 0 configures periodic checkpoints\&.an integer between 0 and 2GB; default \fC0\fP\&. \fC    name\fPthe checkpoint name\&.a string; default \fC'WiredTigerCheckpoint'\fP\&. \fC    wait\fPseconds to wait between each checkpoint; setting this value above 0 configures periodic checkpoints\&.an integer between 0 and 100000; default \fC0\fP\&. \fC )\fP\fCcheckpoint_sync\fPflush files to stable storage when closing or writing checkpoints\&.a boolean flag; default \fCtrue\fP\&. \fCconfig_base\fPwrite the base configuration file if creating the database, see \fBWiredTiger\&.basecfg file\fP for more information\&.a boolean flag; default \fCtrue\fP\&. \fCcreate\fPcreate the database if it does not exist\&.a boolean flag; default \fCfalse\fP\&. \fCdirect_io\fPUse \fCO_DIRECT\fP to access files\&. Options are given as a list, such as \fC'direct_io=[data]'\fP\&. Configuring \fCdirect_io\fP requires care, see \fBDirect I/O\fP for important warnings\&. Including \fC'data'\fP will cause WiredTiger data files to use \fCO_DIRECT\fP, including \fC'log'\fP will cause WiredTiger log files to use \fCO_DIRECT\fP, and including \fC'checkpoint'\fP will cause WiredTiger data files opened at a checkpoint (i\&.e: read only) to use \fCO_DIRECT\fP\&.a list, with values chosen from the following options: \fC'checkpoint'\fP, \fC'data'\fP, \fC'log'\fP; default empty\&. \fCerror_prefix\fPprefix string for error messages\&.a string; default empty\&. \fCeviction = (\fPeviction configuration options\&.a set of related configuration options defined below\&. \fC    threads_max\fPmaximum number of threads WiredTiger will start to help evict pages from cache\&. The number of threads started will vary depending on the current eviction load\&.an integer between 1 and 20; default \fC1\fP\&. \fC    threads_min\fPminimum number of threads WiredTiger will start to help evict pages from cache\&. The number of threads currently running will vary depending on the current eviction load\&.an integer between 1 and 20; default \fC1\fP\&. \fC )\fP\fCeviction_dirty_target\fPcontinue evicting until the cache has less dirty memory than the value, as a percentage of the total cache size\&. Dirty pages will only be evicted if the cache is full enough to trigger eviction\&.an integer between 10 and 99; default \fC80\fP\&. \fCeviction_target\fPcontinue evicting until the cache has less total memory than the value, as a percentage of the total cache size\&. Must be less than \fCeviction_trigger\fP\&.an integer between 10 and 99; default \fC80\fP\&. \fCeviction_trigger\fPtrigger eviction when the cache is using this much memory, as a percentage of the total cache size\&.an integer between 10 and 99; default \fC95\fP\&. \fCexclusive\fPfail if the database already exists, generally used with the \fCcreate\fP option\&.a boolean flag; default \fCfalse\fP\&. \fCextensions\fPlist of shared library extensions to load (using dlopen)\&. Any values specified to an library extension are passed to \fBWT_CONNECTION::load_extension\fP as the \fCconfig\fP parameter (for example, \fCextensions=(/path/ext\&.so={entry=my_entry})\fP)\&.a list of strings; default empty\&. \fCfile_extend\fPfile extension configuration\&. If set, extend files of the set type in allocations of the set size, instead of a block at a time as each new block is written\&. For example, \fCfile_extend=(data=16MB)\fP\&.a list, with values chosen from the following options: \fC'data'\fP, \fC'log'\fP; default empty\&. \fCfile_manager = (\fPcontrol how file handles are managed\&.a set of related configuration options defined below\&. \fC    close_handle_minimum\fPnumber of handles open before the file manager will look for handles to close\&.a string; default \fC250\fP\&. \fC    close_idle_time\fPamount of time in seconds a file handle needs to be idle before attempting to close it\&.an integer between 1 and 100000; default \fC30\fP\&. \fC    close_scan_interval\fPinterval in seconds at which to check for files that are inactive and close them\&.an integer between 1 and 100000; default \fC10\fP\&. \fC )\fP\fChazard_max\fPmaximum number of simultaneous hazard pointers per session handle\&.an integer greater than or equal to 15; default \fC1000\fP\&. \fClog = (\fPenable logging\&.a set of related configuration options defined below\&. \fC    archive\fPautomatically archive unneeded log files\&.a boolean flag; default \fCtrue\fP\&. \fC    compressor\fPconfigure a compressor for log records\&. Permitted values are \fC'none'\fP or custom compression engine name created with \fBWT_CONNECTION::add_compressor\fP\&. If WiredTiger has builtin support for \fC'bzip2'\fP, \fC'snappy'\fP, \fC'lz4'\fP or \fC'zlib'\fP compression, these names are also available\&. See \fBCompressors\fP for more information\&.a string; default \fCnone\fP\&. \fC    enabled\fPenable logging subsystem\&.a boolean flag; default \fCfalse\fP\&. \fC    file_max\fPthe maximum size of log files\&.an integer between 100KB and 2GB; default \fC100MB\fP\&. \fC    path\fPthe path to a directory into which the log files are written\&. If the value is not an absolute path name, the files are created relative to the database home\&.a string; default empty\&. \fC    prealloc\fPpre-allocate log files\&.a boolean flag; default \fCtrue\fP\&. \fC    recover\fPrun recovery or error if recovery needs to run after an unclean shutdown\&.a string, chosen from the following options: \fC'error'\fP, \fC'on'\fP; default \fCon\fP\&. \fC )\fP\fClsm_manager = (\fPconfigure database wide options for LSM tree management\&.a set of related configuration options defined below\&. \fC    merge\fPmerge LSM chunks where possible\&.a boolean flag; default \fCtrue\fP\&. \fC    worker_thread_max\fPConfigure a set of threads to manage merging LSM trees in the database\&.an integer between 3 and 20; default \fC4\fP\&. \fC )\fP\fCmmap\fPUse memory mapping to access files when possible\&.a boolean flag; default \fCtrue\fP\&. \fCmultiprocess\fPpermit sharing between processes (will automatically start an RPC server for primary processes and use RPC for secondary processes)\&. \fBNot yet supported in WiredTiger\fP\&.a boolean flag; default \fCfalse\fP\&. \fCsession_max\fPmaximum expected number of sessions (including server threads)\&.an integer greater than or equal to 1; default \fC100\fP\&. \fCshared_cache = (\fPshared cache configuration options\&. A database should configure either a cache_size or a shared_cache not both\&.a set of related configuration options defined below\&. \fC    chunk\fPthe granularity that a shared cache is redistributed\&.an integer between 1MB and 10TB; default \fC10MB\fP\&. \fC    name\fPthe name of a cache that is shared between databases or \fC'none'\fP when no shared cache is configured\&.a string; default \fCnone\fP\&. \fC    reserve\fPamount of cache this database is guaranteed to have available from the shared cache\&. This setting is per database\&. Defaults to the chunk size\&.an integer; default \fC0\fP\&. \fC    size\fPmaximum memory to allocate for the shared cache\&. Setting this will update the value if one is already set\&.an integer between 1MB and 10TB; default \fC500MB\fP\&. \fC )\fP\fCstatistics\fPMaintain database statistics, which may impact performance\&. Choosing 'all' maintains all statistics regardless of cost, 'fast' maintains a subset of statistics that are relatively inexpensive, 'none' turns off all statistics\&. The 'clear' configuration resets statistics after they are gathered, where appropriate (for example, a cache size statistic is not cleared, while the count of cursor insert operations will be cleared)\&. When 'clear' is configured for the database, gathered statistics are reset each time a statistics cursor is used to gather statistics, as well as each time statistics are logged using the \fCstatistics_log\fP configuration\&. See \fBStatistics\fP for more information\&.a list, with values chosen from the following options: \fC'all'\fP, \fC'fast'\fP, \fC'none'\fP, \fC'clear'\fP; default \fCnone\fP\&. \fCstatistics_log = (\fPlog any statistics the database is configured to maintain, to a file\&. See \fBStatistics\fP for more information\&.a set of related configuration options defined below\&. \fC    on_close\fPlog statistics on database close\&.a boolean flag; default \fCfalse\fP\&. \fC    path\fPthe pathname to a file into which the log records are written, may contain ISO C standard strftime conversion specifications\&. If the value is not an absolute path name, the file is created relative to the database home\&.a string; default \fC'WiredTigerStat\&.%d\&.%H'\fP\&. \fC    sources\fPif non-empty, include statistics for the list of data source URIs, if they are open at the time of the statistics logging\&. The list may include URIs matching a single data source ('table:mytable'), or a URI matching all data sources of a particular type ('table:')\&.a list of strings; default empty\&. \fC    timestamp\fPa timestamp prepended to each log record, may contain strftime conversion specifications\&.a string; default \fC'%b %d %H:%M:%S'\fP\&. \fC    wait\fPseconds to wait between each write of the log records; setting this value above 0 configures statistics logging\&.an integer between 0 and 100000; default \fC0\fP\&. \fC )\fP\fCtransaction_sync = (\fPhow to sync log records when the transaction commits\&.a set of related configuration options defined below\&. \fC    enabled\fPwhether to sync the log on every commit by default, can be overridden by the \fCsync\fP setting to \fBWT_SESSION::begin_transaction\fP\&.a boolean flag; default \fCfalse\fP\&. \fC    method\fPthe method used to ensure log records are stable on disk, see \fBCommit-level durability\fP for more information\&.a string, chosen from the following options: \fC'dsync'\fP, \fC'fsync'\fP, \fC'none'\fP; default \fCfsync\fP\&. \fC )\fP\fCuse_environment_priv\fPuse the \fCWIREDTIGER_CONFIG\fP and \fCWIREDTIGER_HOME\fP environment variables regardless of whether or not the process is running with special privileges\&. See \fBDatabase Home Directory\fP for more information\&.a boolean flag; default \fCfalse\fP\&. \fCverbose\fPenable messages for various events\&. Only available if WiredTiger is configured with --enable-verbose\&. Options are given as a list, such as \fC'verbose=[evictserver,read]'\fP\&.a list, with values chosen from the following options: \fC'api'\fP, \fC'block'\fP, \fC'checkpoint'\fP, \fC'compact'\fP, \fC'evict'\fP, \fC'evictserver'\fP, \fC'fileops'\fP, \fC'log'\fP, \fC'lsm'\fP, \fC'metadata'\fP, \fC'mutex'\fP, \fC'overflow'\fP, \fC'read'\fP, \fC'reconcile'\fP, \fC'recovery'\fP, \fC'salvage'\fP, \fC'shared_cache'\fP, \fC'split'\fP, \fC'temporary'\fP, \fC'transaction'\fP, \fC'verify'\fP, \fC'version'\fP, \fC'write'\fP; default empty\&. Additionally, if files named \fCWiredTiger\&.config\fP or \fCWiredTiger\&.basecfg\fP appear in the WiredTiger home directory, they are read for configuration values (see \fBWiredTiger\&.config file\fP and \fBWiredTiger\&.basecfg file\fP for details)\&. See \fBConfiguration ordering\fP for ordering of the configuration mechanisms\&. 
.br
\fIconnectionp\fP A pointer to the newly opened connection handle 
.RE
.PP
\fBReturns:\fP
.RS 4
zero on success and a non-zero error code on failure\&. See \fBError Returns\fP for details\&. 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
\fBex_access\&.c\fP, \fBex_async\&.c\fP, \fBex_call_center\&.c\fP, \fBex_config\&.c\fP, \fBex_cursor\&.c\fP, \fBex_extending\&.c\fP, \fBex_extractor\&.c\fP, \fBex_hello\&.c\fP, \fBex_log\&.c\fP, \fBex_pack\&.c\fP, \fBex_schema\&.c\fP, \fBex_stat\&.c\fP, and \fBex_thread\&.c\fP\&.
.SS "int wiredtiger_pack_close (\fBWT_PACK_STREAM\fP *ps, size_t *usedp)"

.PP
Close a packing stream\&. 
.PP
\fBParameters:\fP
.RS 4
\fIps\fP the packing stream handle 
.br
\fIusedp\fP the number of bytes in the buffer used by the stream 
.RE
.PP
\fBReturns:\fP
.RS 4
zero on success and a non-zero error code on failure\&. See \fBError Returns\fP for details\&. 
.RE
.PP

.SS "int wiredtiger_pack_int (\fBWT_PACK_STREAM\fP *ps, int64_ti)"

.PP
Pack a signed integer into a packing stream\&. 
.PP
\fBParameters:\fP
.RS 4
\fIps\fP the packing stream handle 
.br
\fIi\fP a signed integer to pack 
.RE
.PP
\fBReturns:\fP
.RS 4
zero on success and a non-zero error code on failure\&. See \fBError Returns\fP for details\&. 
.RE
.PP

.SS "int wiredtiger_pack_item (\fBWT_PACK_STREAM\fP *ps, \fBWT_ITEM\fP *item)"

.PP
Pack an item into a packing stream\&. 
.PP
\fBParameters:\fP
.RS 4
\fIps\fP the packing stream handle 
.br
\fIitem\fP an item to pack 
.RE
.PP
\fBReturns:\fP
.RS 4
zero on success and a non-zero error code on failure\&. See \fBError Returns\fP for details\&. 
.RE
.PP

.SS "int wiredtiger_pack_start (\fBWT_SESSION\fP *session, const char *format, void *buffer, size_tsize, \fBWT_PACK_STREAM\fP **psp)"

.PP
Start a packing operation into a buffer with the given format string\&. This should be followed by a series of calls to \fBwiredtiger_pack_item\fP, \fBwiredtiger_pack_int\fP, \fBwiredtiger_pack_str\fP or \fBwiredtiger_pack_uint\fP to fill in the values\&.
.PP
\fBParameters:\fP
.RS 4
\fIsession\fP the session handle 
.br
\fIformat\fP the data format, see \fBPacking and Unpacking Data\fP 
.br
\fIbuffer\fP a pointer to memory to hold the packed data 
.br
\fIsize\fP the size of the buffer 
.br
\fIpsp\fP the new packing stream handle 
.RE
.PP
\fBReturns:\fP
.RS 4
zero on success and a non-zero error code on failure\&. See \fBError Returns\fP for details\&. 
.RE
.PP

.SS "int wiredtiger_pack_str (\fBWT_PACK_STREAM\fP *ps, const char *s)"

.PP
Pack a string into a packing stream\&. 
.PP
\fBParameters:\fP
.RS 4
\fIps\fP the packing stream handle 
.br
\fIs\fP a string to pack 
.RE
.PP
\fBReturns:\fP
.RS 4
zero on success and a non-zero error code on failure\&. See \fBError Returns\fP for details\&. 
.RE
.PP

.SS "int wiredtiger_pack_uint (\fBWT_PACK_STREAM\fP *ps, uint64_tu)"

.PP
Pack an unsigned integer into a packing stream\&. 
.PP
\fBParameters:\fP
.RS 4
\fIps\fP the packing stream handle 
.br
\fIu\fP an unsigned integer to pack 
.RE
.PP
\fBReturns:\fP
.RS 4
zero on success and a non-zero error code on failure\&. See \fBError Returns\fP for details\&. 
.RE
.PP

.SS "const char* wiredtiger_strerror (interror)"

.PP
Return information about a WiredTiger error as a string, not thread-safe\&. 
.PP
.nf
     const char *key = "non-existent key";
        cursor->set_key(cursor, key);
        if ((ret = cursor->remove(cursor)) != 0) {
                fprintf(stderr,
                    "cursor\&.remove: %s\n",
                    cursor->session->strerror(cursor->session, ret));
                return (ret);
        }

.fi
.PP
 
.PP
\fBParameters:\fP
.RS 4
\fIerror\fP a return value from a WiredTiger call 
.RE
.PP
\fBReturns:\fP
.RS 4
a string representation of the error 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
\fBex_access\&.c\fP, \fBex_async\&.c\fP, \fBex_call_center\&.c\fP, \fBex_config\&.c\fP, \fBex_cursor\&.c\fP, \fBex_extending\&.c\fP, \fBex_hello\&.c\fP, \fBex_log\&.c\fP, \fBex_pack\&.c\fP, \fBex_schema\&.c\fP, and \fBex_thread\&.c\fP\&.
.SS "int wiredtiger_struct_pack (\fBWT_SESSION\fP *session, void *buffer, size_tsize, const char *format, \&.\&.\&.)"

.PP
Pack a structure into a buffer\&. See \fBPacking and Unpacking Data\fP for a description of the permitted format strings\&.
.SH "Packing Examples"
.PP
For example, the string \fC'iSh'\fP will pack a 32-bit integer followed by a NUL-terminated string, followed by a 16-bit integer\&. The default, big-endian encoding will be used, with no alignment\&. This could be used in C as follows:
.PP
.PP
.nf
 char buf[100];
        ret = wiredtiger_struct_pack(
            session, buf, sizeof(buf), "iSh", 42, "hello", -3);
.fi
.PP
 Then later, the values can be unpacked as follows:
.PP
.PP
.nf
        int i;
        char *s;
        short h;
        ret = wiredtiger_struct_unpack(
            session, buf, sizeof(buf), "iSh", &i, &s, &h);
.fi
.PP
 
.PP
\fBParameters:\fP
.RS 4
\fIsession\fP the session handle 
.br
\fIbuffer\fP a pointer to a packed byte array 
.br
\fIsize\fP the number of valid bytes in the buffer 
.br
\fIformat\fP the data format, see \fBPacking and Unpacking Data\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
zero on success and a non-zero error code on failure\&. See \fBError Returns\fP for details\&. 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
\fBex_pack\&.c\fP\&.
.SS "int wiredtiger_struct_size (\fBWT_SESSION\fP *session, size_t *sizep, const char *format, \&.\&.\&.)"

.PP
Calculate the size required to pack a structure\&. Note that for variable-sized fields including variable-sized strings and integers, the calculated sized merely reflects the expected sizes specified in the format string itself\&.
.PP
.PP
.nf
   size_t size;
        ret = wiredtiger_struct_size(session, &size, "iSh", 42, "hello", -3);
.fi
.PP
 
.PP
\fBParameters:\fP
.RS 4
\fIsession\fP the session handle 
.br
\fIsizep\fP a location where the number of bytes needed for the matching call to \fBwiredtiger_struct_pack\fP is returned 
.br
\fIformat\fP the data format, see \fBPacking and Unpacking Data\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
zero on success and a non-zero error code on failure\&. See \fBError Returns\fP for details\&. 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
\fBex_pack\&.c\fP\&.
.SS "int wiredtiger_struct_unpack (\fBWT_SESSION\fP *session, const void *buffer, size_tsize, const char *format, \&.\&.\&.)"

.PP
Unpack a structure from a buffer\&. Reverse of \fBwiredtiger_struct_pack\fP: gets values out of a packed byte string\&.
.PP
.PP
.nf
        int i;
        char *s;
        short h;
        ret = wiredtiger_struct_unpack(
            session, buf, sizeof(buf), "iSh", &i, &s, &h);
.fi
.PP
 
.PP
\fBParameters:\fP
.RS 4
\fIsession\fP the session handle 
.br
\fIbuffer\fP a pointer to a packed byte array 
.br
\fIsize\fP the number of valid bytes in the buffer 
.br
\fIformat\fP the data format, see \fBPacking and Unpacking Data\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
zero on success and a non-zero error code on failure\&. See \fBError Returns\fP for details\&. 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
\fBex_extractor\&.c\fP, \fBex_pack\&.c\fP, and \fBex_schema\&.c\fP\&.
.SS "int wiredtiger_unpack_int (\fBWT_PACK_STREAM\fP *ps, int64_t *ip)"

.PP
Unpack a signed integer from a packing stream\&. 
.PP
\fBParameters:\fP
.RS 4
\fIps\fP the packing stream handle 
.br
\fIip\fP the unpacked signed integer 
.RE
.PP
\fBReturns:\fP
.RS 4
zero on success and a non-zero error code on failure\&. See \fBError Returns\fP for details\&. 
.RE
.PP

.SS "int wiredtiger_unpack_item (\fBWT_PACK_STREAM\fP *ps, \fBWT_ITEM\fP *item)"

.PP
Unpack an item from a packing stream\&. 
.PP
\fBParameters:\fP
.RS 4
\fIps\fP the packing stream handle 
.br
\fIitem\fP an item to unpack 
.RE
.PP
\fBReturns:\fP
.RS 4
zero on success and a non-zero error code on failure\&. See \fBError Returns\fP for details\&. 
.RE
.PP

.SS "int wiredtiger_unpack_start (\fBWT_SESSION\fP *session, const char *format, const void *buffer, size_tsize, \fBWT_PACK_STREAM\fP **psp)"

.PP
Start an unpacking operation from a buffer with the given format string\&. This should be followed by a series of calls to \fBwiredtiger_unpack_item\fP, \fBwiredtiger_unpack_int\fP, \fBwiredtiger_unpack_str\fP or \fBwiredtiger_unpack_uint\fP to retrieve the packed values\&.
.PP
\fBParameters:\fP
.RS 4
\fIsession\fP the session handle 
.br
\fIformat\fP the data format, see \fBPacking and Unpacking Data\fP 
.br
\fIbuffer\fP a pointer to memory holding the packed data 
.br
\fIsize\fP the size of the buffer 
.br
\fIpsp\fP the new packing stream handle 
.RE
.PP
\fBReturns:\fP
.RS 4
zero on success and a non-zero error code on failure\&. See \fBError Returns\fP for details\&. 
.RE
.PP

.SS "int wiredtiger_unpack_str (\fBWT_PACK_STREAM\fP *ps, const char **sp)"

.PP
Unpack a string from a packing stream\&. 
.PP
\fBParameters:\fP
.RS 4
\fIps\fP the packing stream handle 
.br
\fIsp\fP the unpacked string 
.RE
.PP
\fBReturns:\fP
.RS 4
zero on success and a non-zero error code on failure\&. See \fBError Returns\fP for details\&. 
.RE
.PP

.SS "int wiredtiger_unpack_uint (\fBWT_PACK_STREAM\fP *ps, uint64_t *up)"

.PP
Unpack an unsigned integer from a packing stream\&. 
.PP
\fBParameters:\fP
.RS 4
\fIps\fP the packing stream handle 
.br
\fIup\fP the unpacked unsigned integer 
.RE
.PP
\fBReturns:\fP
.RS 4
zero on success and a non-zero error code on failure\&. See \fBError Returns\fP for details\&. 
.RE
.PP

.SS "const char* wiredtiger_version (int *majorp, int *minorp, int *patchp)"

.PP
Get version information\&. 
.PP
.nf
   printf("WiredTiger version %s\n", wiredtiger_version(NULL, NULL, NULL));

.fi
.PP
.PP
.nf
        int major_v, minor_v, patch;
        (void)wiredtiger_version(&major_v, &minor_v, &patch);
        printf("WiredTiger version is %d, %d (patch %d)\n",
            major_v, minor_v, patch);
.fi
.PP
 
.PP
\fBParameters:\fP
.RS 4
\fImajorp\fP a location where the major version number is returned 
.br
\fIminorp\fP a location where the minor version number is returned 
.br
\fIpatchp\fP a location where the patch version number is returned 
.RE
.PP
\fBReturns:\fP
.RS 4
a string representation of the version 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for WiredTiger from the source code\&.
