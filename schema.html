<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>WiredTiger: Schemas</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="wiredtiger.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>


</head>
<body>
<div id="top"><!-- do not remove this div! -->

<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  <td id="projectlogo">
    <div class="logo"><a href="http://wiredtiger.com/"><img src="images/LogoFinal-header.png" alt="WiredTiger" /></a></div>
  </td>
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Version 0.10.0</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li><a href="https://github.com/wiredtiger/wiredtiger"><span>Download</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('schema.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Schemas </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>While many tables have simple key/value pairs for records, WiredTiger also supports more complex data patterns.</p>
<h2><a class="anchor" id="schema_intro"></a>
Tables, rows and columns</h2>
<p>A table is a logical representation of data consisting of cells in rows and columns. For example, a database might have this table.</p>
<table class="doxtable">
<tr>
<th>EmpId</th><th>Lastname</th><th>Firstname</th><th>Salary </th></tr>
<tr>
<td>1</td><td>Smith</td><td>Joe</td><td>40000 </td></tr>
<tr>
<td>2</td><td>Jones</td><td>Mary</td><td>50000 </td></tr>
<tr>
<td>3</td><td>Johnson</td><td>Cathy</td><td>44000 </td></tr>
</table>
<p>This simple table includes an employee identifier, last name and first name, and a salary.</p>
<p>A row-oriented database would store all of the values in a row together, then the values in the next row, and so on:</p>
<pre>
      1,Smith,Joe,40000;
      2,Jones,Mary,50000;
      3,Johnson,Cathy,44000;
</pre><p>A column-oriented database stores all of the values of a column together, then the values of the next column, and so on:</p>
<pre>
      1,2,3;
      Smith,Jones,Johnson;
      Joe,Mary,Cathy;
      40000,50000,44000;
</pre><p>WiredTiger supports both storage formats, and can mix and match the storage of columns within a logical table.</p>
<p>Applications describe the format of their data by supplying a schema to <a class="el" href="struct_w_t___s_e_s_s_i_o_n.html#a358ca4141d59c345f401c58501276bbb" title="Create a table, column group, index or file.">WT_SESSION::create</a>. This specifies how the application's data can be split into fields and mapped onto rows and columns.</p>
<h2><a class="anchor" id="schema_types"></a>
Column types</h2>
<p>By default, WiredTiger works as a traditional key/value store, where the keys and values are raw byte arrays accessed using a <a class="el" href="struct_w_t___i_t_e_m.html" title="A raw item of data to be managed.">WT_ITEM</a> structure. Keys and values may be up to (4GB - 512B) bytes in size, but depending on how <a class="el" href="struct_w_t___s_e_s_s_i_o_n.html#a358ca4141d59c345f401c58501276bbb">maximum item sizes</a> are configured, large key and value items will be stored on overflow pages.</p>
<p>See <a class="el" href="keyvalue.html">Key/Value pairs</a> for more details on raw key / value items.</p>
<p>The schema layer allows key and value types to be chosen from a list, or composite keys or values made up of columns with any combination of types. The size (4GB - 512B) byte limit on keys and values still applies.</p>
<p>WiredTiger's uses format strings similar to those specified in the Python struct module to describe the types of columns in a table: <a href="http://docs.python.org/library/struct">http://docs.python.org/library/struct</a></p>
<h2><a class="anchor" id="schema_format_types"></a>
Format types</h2>
<table class="doxtable">
<tr>
<th>Format</th><th>C Type</th><th>Java type</th><th>Python type</th><th>Standard size </th></tr>
<tr>
<td>x</td><td>pad byte</td><td>N/A</td><td>N/A</td><td>1 </td></tr>
<tr>
<td>b</td><td>signed char</td><td>byte</td><td>integer</td><td>1 </td></tr>
<tr>
<td>B</td><td>unsigned char</td><td>byte</td><td>integer</td><td>1 </td></tr>
<tr>
<td>h</td><td>short</td><td>short</td><td>integer</td><td>2 </td></tr>
<tr>
<td>H</td><td>unsigned short</td><td>short</td><td>integer</td><td>2 </td></tr>
<tr>
<td>i</td><td>int</td><td>int</td><td>integer</td><td>4 </td></tr>
<tr>
<td>I</td><td>unsigned int</td><td>int</td><td>integer</td><td>4 </td></tr>
<tr>
<td>l</td><td>long</td><td>int</td><td>integer</td><td>4 </td></tr>
<tr>
<td>L</td><td>unsigned long</td><td>int</td><td>integer</td><td>4 </td></tr>
<tr>
<td>q</td><td>long long</td><td>long</td><td>integer</td><td>8 </td></tr>
<tr>
<td>Q</td><td>unsigned long long</td><td>long</td><td>integer</td><td>8 </td></tr>
<tr>
<td>r</td><td>uint64_t</td><td>long</td><td>integer</td><td>8 </td></tr>
<tr>
<td>s</td><td>char[]</td><td>String</td><td>string</td><td>fixed length </td></tr>
<tr>
<td>S</td><td>char[]</td><td>String</td><td>string</td><td>variable </td></tr>
<tr>
<td>t</td><td>unsigned char</td><td>byte</td><td>integer</td><td>fixed bit length </td></tr>
<tr>
<td>u</td><td><a class="el" href="struct_w_t___i_t_e_m.html" title="A raw item of data to be managed.">WT_ITEM</a> *</td><td>byte[]</td><td>string</td><td>variable </td></tr>
</table>
<p>The <code>'r'</code> type is used for record number keys in column stores.</p>
<p>The <code>'S'</code> type is encoded as a C language string terminated by a NUL character.</p>
<p>The <code>'t'</code> type is used for fixed-length bit field values. If it is preceded by a size, that indicates the number of bits to store, between 1 and 8. That number of low-order bits will be stored in the table. The default is a size of 1 bit: that is, a boolean. The application must always use an <code>unsigned char</code> type (or equivalently, <code>uint8_t</code>) for calls to <a class="el" href="struct_w_t___c_u_r_s_o_r.html#a27f7cbd0cd3e561f6a145704813ad64c" title="Set the value for the next operation.">WT_CURSOR::set_value</a>, and a pointer to the same for calls to <a class="el" href="struct_w_t___c_u_r_s_o_r.html#af85364a5af50b95bbc46c82e72f75c01" title="Get the value for the current record.">WT_CURSOR::get_value</a>. If a bit field value is combined with other types in a packing format, it is equivalent to <code>'B'</code>, and a full byte is used to store it.</p>
<p>When referenced by a record number (that is, a key format of <code>'r'</code>), the <code>'t'</code> type will be stored in a fixed-length column-store, and will not have a out-of-band value to indicate the record does not exist. In this case, a 0 byte value is used to indicate the record does not exist. This means removing a record with <a class="el" href="struct_w_t___c_u_r_s_o_r.html#abbba24fe607fee519c4c9c4669cd4455" title="Remove a record.">WT_CURSOR::remove</a> is equivalent to storing a value of 0 in the record with <a class="el" href="struct_w_t___c_u_r_s_o_r.html#a444cdc0952e7f8d55d23173516c7037f" title="Update a record.">WT_CURSOR::update</a> (and storing a value of 0 in the record will cause cursor scans to skip the record). Additionally, creating a record past the end of the table or file implies the creation of any missing intermediate records, with byte values of 0.</p>
<p>The <code>'u'</code> type is for raw byte arrays: if it appears at the end of a format string (including in the default <code>"u"</code> format for untyped tables), the size is not stored explicitly. When <code>'u'</code> appears within a format string, the size is stored as a 32-bit integer in the same byte order as the rest of the format string, followed by the data.</p>
<p>There is a default collator that gives lexicographic (byte-wise) comparisons, and the default encoding is designed so that lexicographic ordering of encoded keys is usually the expected ordering. For example, the variable-length encoding of integers is designed so that they have the natural integer ordering under the default collator.</p>
<p>See <a class="el" href="packing.html">Packing and Unpacking Data</a> for details of WiredTiger's packing format.</p>
<p>WiredTiger can also be extended with <a class="el" href="struct_w_t___c_o_l_l_a_t_o_r.html">WT_COLLATOR</a>.</p>
<h2><a class="anchor" id="schema_data_access"></a>
Columns in key and values</h2>
<p>Every table has a key format and a value format as describe in <a class="el" href="schema.html#schema_types">Column types</a>. These types are configured when the table is created by passing <code>key_format</code> and <code>value_format</code> keys to <a class="el" href="struct_w_t___s_e_s_s_i_o_n.html#a358ca4141d59c345f401c58501276bbb" title="Create a table, column group, index or file.">WT_SESSION::create</a>.</p>
<p>Cursors for a table have the same key format as the table itself. The key columns of a cursor are set with <a class="el" href="struct_w_t___c_u_r_s_o_r.html#ad1088d719df40babc1f57d086691ebdc" title="Set the key for the next operation.">WT_CURSOR::set_key</a> and accessed with <a class="el" href="struct_w_t___c_u_r_s_o_r.html#af19f6f9d9c7fc248ab38879032620b2f" title="Get the key for the current record.">WT_CURSOR::get_key</a>. <a class="el" href="struct_w_t___c_u_r_s_o_r.html#ad1088d719df40babc1f57d086691ebdc" title="Set the key for the next operation.">WT_CURSOR::set_key</a> is analogous to <code>printf</code>, and takes a list of values in the order the key columns are configured in <code>key_format</code>. The columns values are accessed with <a class="el" href="struct_w_t___c_u_r_s_o_r.html#af19f6f9d9c7fc248ab38879032620b2f" title="Get the key for the current record.">WT_CURSOR::get_key</a>, which is analogous to <code>scanf</code>, and takes a list of pointers to values in the same order.</p>
<p>Cursors for a table have the same value format as the table, unless a projection is specified to <a class="el" href="struct_w_t___s_e_s_s_i_o_n.html#afb5b4a69c2c5cafe411b2b04fdc1c75d" title="Open a cursor.">WT_SESSION::open_cursor</a>. <a class="el" href="struct_w_t___c_u_r_s_o_r.html#a27f7cbd0cd3e561f6a145704813ad64c" title="Set the value for the next operation.">WT_CURSOR::set_value</a> is used to set value columns, and <a class="el" href="struct_w_t___c_u_r_s_o_r.html#af85364a5af50b95bbc46c82e72f75c01" title="Get the value for the current record.">WT_CURSOR::get_value</a> is used to get value columns.</p>
<h2><a class="anchor" id="schema_columns"></a>
Describing columns</h2>
<p>The columns in a table can be assigned names by passing a <code>columns</code> key to <a class="el" href="struct_w_t___s_e_s_s_i_o_n.html#a358ca4141d59c345f401c58501276bbb" title="Create a table, column group, index or file.">WT_SESSION::create</a>. The column names are assigned first to the columns in the <code>key_format</code>, and then to the columns in <code>value_format</code>. There must be a name for every column, and no column names may be repeated.</p>
<h2><a class="anchor" id="schema_column_groups"></a>
Storing groups of columns together</h2>
<p>Once column names are assigned, they can be used to configure column groups, where groups of columns are stored in separate files.</p>
<p>There are two steps involved in setting up column groups: first, pass a list of names for the column groups in the <code>colgroups</code> configuration key to <a class="el" href="struct_w_t___s_e_s_s_i_o_n.html#a358ca4141d59c345f401c58501276bbb" title="Create a table, column group, index or file.">WT_SESSION::create</a>. Then make a call to <a class="el" href="struct_w_t___s_e_s_s_i_o_n.html#a358ca4141d59c345f401c58501276bbb" title="Create a table, column group, index or file.">WT_SESSION::create</a> for each column group, using the URI <code>colgroup:&lt;table&gt;:&lt;colgroup name&gt;</code> and a <code>columns</code> key in the configuration. Columns can be stored in multiple column groups, but all value columns must appear in at least on column group.</p>
<p>Column groups have the same key as the table. This is particularly useful for column stores, because record numbers are not stored explicitly on disk, so there is no repetition of keys across multiple files. Also note that key columns cannot be stored in column group values: they can be retrieved with <a class="el" href="struct_w_t___c_u_r_s_o_r.html#af19f6f9d9c7fc248ab38879032620b2f" title="Get the key for the current record.">WT_CURSOR::get_key</a>.</p>
<h2><a class="anchor" id="schema_indices"></a>
Adding an index</h2>
<p>Schema columns can also be used to configure indices on tables. To create an index, call <a class="el" href="struct_w_t___s_e_s_s_i_o_n.html#a358ca4141d59c345f401c58501276bbb" title="Create a table, column group, index or file.">WT_SESSION::create</a> using the URI <code>index:&lt;table&gt;:&lt;index name&gt;</code> and include a <code>columns</code> key in the configuration. WiredTiger updates all indices for a table whenever the table is modified.</p>
<p>A cursor can be opened on an index by passing the index URI to <a class="el" href="struct_w_t___s_e_s_s_i_o_n.html#afb5b4a69c2c5cafe411b2b04fdc1c75d" title="Open a cursor.">WT_SESSION::open_cursor</a>. Index cursors use the specified index key columns for <a class="el" href="struct_w_t___c_u_r_s_o_r.html#af19f6f9d9c7fc248ab38879032620b2f" title="Get the key for the current record.">WT_CURSOR::get_key</a> and <a class="el" href="struct_w_t___c_u_r_s_o_r.html#ad1088d719df40babc1f57d086691ebdc" title="Set the key for the next operation.">WT_CURSOR::set_key</a>, and by default return all of the table value columns in <a class="el" href="struct_w_t___c_u_r_s_o_r.html#af85364a5af50b95bbc46c82e72f75c01" title="Get the value for the current record.">WT_CURSOR::get_value</a>. Index cursors are read-only: they cannot be used to perform updates.</p>
<h2><a class="anchor" id="schema_examples"></a>
Code samples</h2>
<p>The code below is taken from the complete example program <a class="el" href="ex_schema_8c-example.html">ex_schema.c</a>, available in the source tree as <code>examples/c/\1</code>.</p>
<div class="fragment"><pre class="fragment"><span class="comment">/* The C struct for the data we are storing with WiredTiger. */</span>
<span class="keyword">typedef</span> <span class="keyword">struct </span>{
        <span class="keywordtype">char</span> country[5];
        uint16_t year;
        uint64_t population;
} POP_RECORD;
</pre></div><div class="fragment"><pre class="fragment">        ret = conn-&gt;<a class="code" href="struct_w_t___c_o_n_n_e_c_t_i_o_n.html#afc75c44ff4497627c59d9b6aaa64c9d8" title="Open a session.">open_session</a>(conn, NULL, NULL, &amp;session);

        <span class="comment">/*</span>
<span class="comment">         * Create the population table.</span>
<span class="comment">         * Keys are record numbers, the format for values is</span>
<span class="comment">         * (5-byte string, short, long).</span>
<span class="comment">         * See ::wiredtiger_struct_pack for details of the format strings.</span>
<span class="comment">         *</span>
<span class="comment">         * If this program is run multiple times so the table already exists,</span>
<span class="comment">         * this call will verify that the table exists.  It is not required in</span>
<span class="comment">         * that case, but is a safety check that the schema matches what the</span>
<span class="comment">         * program expects.</span>
<span class="comment">         */</span>
        ret = session-&gt;<a class="code" href="struct_w_t___s_e_s_s_i_o_n.html#a358ca4141d59c345f401c58501276bbb" title="Create a table, column group, index or file.">create</a>(session, <span class="stringliteral">&quot;table:population&quot;</span>,
            <span class="stringliteral">&quot;key_format=r,&quot;</span>
            <span class="stringliteral">&quot;value_format=5sHQ,&quot;</span>
            <span class="stringliteral">&quot;columns=(id,country,year,population),&quot;</span>
            <span class="stringliteral">&quot;colgroups=(main,population)&quot;</span>);

        <span class="comment">/* Create the column groups to store population in its own file. */</span>
        ret = session-&gt;<a class="code" href="struct_w_t___s_e_s_s_i_o_n.html#a358ca4141d59c345f401c58501276bbb" title="Create a table, column group, index or file.">create</a>(session, <span class="stringliteral">&quot;colgroup:population:main&quot;</span>,
            <span class="stringliteral">&quot;columns=(country,year)&quot;</span>);

        ret = session-&gt;<a class="code" href="struct_w_t___s_e_s_s_i_o_n.html#a358ca4141d59c345f401c58501276bbb" title="Create a table, column group, index or file.">create</a>(session, <span class="stringliteral">&quot;colgroup:population:population&quot;</span>,
            <span class="stringliteral">&quot;columns=(population)&quot;</span>);

        <span class="comment">/* Create an index with composite key (country,year). */</span>
        ret = session-&gt;<a class="code" href="struct_w_t___s_e_s_s_i_o_n.html#a358ca4141d59c345f401c58501276bbb" title="Create a table, column group, index or file.">create</a>(session, <span class="stringliteral">&quot;index:population:country_year&quot;</span>,
            <span class="stringliteral">&quot;columns=(country,year)&quot;</span>);

        ret = session-&gt;<a class="code" href="struct_w_t___s_e_s_s_i_o_n.html#afb5b4a69c2c5cafe411b2b04fdc1c75d" title="Open a cursor.">open_cursor</a>(session, <span class="stringliteral">&quot;table:population&quot;</span>,
            NULL, <span class="stringliteral">&quot;append&quot;</span>, &amp;cursor);

        endp = pop_data + (<span class="keyword">sizeof</span> (pop_data) / <span class="keyword">sizeof</span> (pop_data[0]));
        <span class="keywordflow">for</span> (p = pop_data; p &lt; endp; p++) {
                cursor-&gt;<a class="code" href="struct_w_t___c_u_r_s_o_r.html#a27f7cbd0cd3e561f6a145704813ad64c" title="Set the value for the next operation.">set_value</a>(cursor, p-&gt;country, p-&gt;year, p-&gt;population);
                ret = cursor-&gt;<a class="code" href="struct_w_t___c_u_r_s_o_r.html#aac90d9fbcc031570f924db55f8a1cee3" title="Insert a record, and optionally overwrite an existing record.">insert</a>(cursor);
        }
        ret = cursor-&gt;<a class="code" href="struct_w_t___c_u_r_s_o_r.html#ae5e6412ab3d895d68f454e59963fd391" title="Close the cursor.">close</a>(cursor, NULL);

        <span class="comment">/* Now just read through the countries we know about */</span>
        ret = session-&gt;<a class="code" href="struct_w_t___s_e_s_s_i_o_n.html#afb5b4a69c2c5cafe411b2b04fdc1c75d" title="Open a cursor.">open_cursor</a>(session,
            <span class="stringliteral">&quot;index:population:country_year(id)&quot;</span>,
            NULL, NULL, &amp;cursor);

        <span class="keywordflow">while</span> ((ret = cursor-&gt;<a class="code" href="struct_w_t___c_u_r_s_o_r.html#a0503f16bd8f3d05aa3552f229b3a8e1b" title="Return the next record.">next</a>(cursor)) == 0) {
                cursor-&gt;<a class="code" href="struct_w_t___c_u_r_s_o_r.html#af19f6f9d9c7fc248ab38879032620b2f" title="Get the key for the current record.">get_key</a>(cursor, &amp;country, &amp;year);
                cursor-&gt;<a class="code" href="struct_w_t___c_u_r_s_o_r.html#af85364a5af50b95bbc46c82e72f75c01" title="Get the value for the current record.">get_value</a>(cursor, &amp;recno);

                printf(<span class="stringliteral">&quot;Got country %s : row ID %d\n&quot;</span>, country, (<span class="keywordtype">int</span>)recno);
        }

        ret = conn-&gt;<a class="code" href="struct_w_t___c_o_n_n_e_c_t_i_o_n.html#af535c517df851eeac8ebf3594d40b545" title="Close a connection.">close</a>(conn, NULL);
</pre></div><p> The code below is taken from the complete example program <a class="el" href="ex_call_center_8c-example.html">ex_call_center.c</a>, available in the source tree as <code>examples/c/\1</code>.</p>
<div class="fragment"><pre class="fragment"><span class="comment">/*</span>
<span class="comment"> * In SQL, the tables are described as follows:</span>
<span class="comment"> *</span>
<span class="comment"> * CREATE TABLE Customers(id INTEGER PRIMARY KEY,</span>
<span class="comment"> *     name VARCHAR(30), address VARCHAR(50), phone VARCHAR(15))</span>
<span class="comment"> * CREATE INDEX CustomersPhone ON Customers(phone)</span>
<span class="comment"> *</span>
<span class="comment"> * CREATE TABLE Calls(id INTEGER PRIMARY KEY, call_date DATE,</span>
<span class="comment"> *     cust_id INTEGER, emp_id INTEGER, call_type VARCHAR(12),</span>
<span class="comment"> *     notes VARCHAR(25))</span>
<span class="comment"> * CREATE INDEX CallsCustDate ON Calls(cust_id, call_date)</span>
<span class="comment"> *</span>
<span class="comment"> * In this example, both tables will use record numbers for their IDs, which</span>
<span class="comment"> * will be the key.  The C structs for the records are as follows.</span>
<span class="comment"> */</span>

<span class="comment">/* Customer records. */</span>
<span class="keyword">typedef</span> <span class="keyword">struct </span>{
        uint64_t id;
        <span class="keywordtype">char</span> *name;
        <span class="keywordtype">char</span> *address;
        <span class="keywordtype">char</span> *phone;
} CUSTOMER;

<span class="comment">/* Call records. */</span>
<span class="keyword">typedef</span> <span class="keyword">struct </span>{
        uint64_t id;
        uint64_t call_date;
        uint64_t cust_id;
        uint64_t emp_id;
        <span class="keywordtype">char</span> *call_type;
        <span class="keywordtype">char</span> *notes;
} CALL;
</pre></div><div class="fragment"><pre class="fragment">        ret = conn-&gt;<a class="code" href="struct_w_t___c_o_n_n_e_c_t_i_o_n.html#afc75c44ff4497627c59d9b6aaa64c9d8" title="Open a session.">open_session</a>(conn, NULL, NULL, &amp;session);

        <span class="comment">/*</span>
<span class="comment">         * Create the customers table, give names and types to the columns.</span>
<span class="comment">         * The columns will be stored in two groups: &quot;main&quot; and &quot;address&quot;,</span>
<span class="comment">         * created below.</span>
<span class="comment">         */</span>
        ret = session-&gt;<a class="code" href="struct_w_t___s_e_s_s_i_o_n.html#a358ca4141d59c345f401c58501276bbb" title="Create a table, column group, index or file.">create</a>(session, <span class="stringliteral">&quot;table:customers&quot;</span>,
            <span class="stringliteral">&quot;key_format=S,&quot;</span>
            <span class="stringliteral">&quot;value_format=SSS,&quot;</span>
            <span class="stringliteral">&quot;columns=(id,name,address,phone),&quot;</span>
            <span class="stringliteral">&quot;colgroups=(main,address)&quot;</span>);

        <span class="comment">/* Create the main column group with value columns except address. */</span>
        ret = session-&gt;<a class="code" href="struct_w_t___s_e_s_s_i_o_n.html#a358ca4141d59c345f401c58501276bbb" title="Create a table, column group, index or file.">create</a>(session,
            <span class="stringliteral">&quot;colgroup:customers:main&quot;</span>, <span class="stringliteral">&quot;columns=(name,phone)&quot;</span>);

        <span class="comment">/* Create the address column group with just the address. */</span>
        ret = session-&gt;<a class="code" href="struct_w_t___s_e_s_s_i_o_n.html#a358ca4141d59c345f401c58501276bbb" title="Create a table, column group, index or file.">create</a>(session,
            <span class="stringliteral">&quot;colgroup:customers:address&quot;</span>, <span class="stringliteral">&quot;columns=(address)&quot;</span>);

        <span class="comment">/* Create an index on the customer table by phone number. */</span>
        ret = session-&gt;<a class="code" href="struct_w_t___s_e_s_s_i_o_n.html#a358ca4141d59c345f401c58501276bbb" title="Create a table, column group, index or file.">create</a>(session,
            <span class="stringliteral">&quot;index:customers:phone&quot;</span>, <span class="stringliteral">&quot;columns=(phone)&quot;</span>);

        <span class="comment">/*</span>
<span class="comment">         * Create the calls table, give names and types to the columns.</span>
<span class="comment">         * All of the columns will be stored together, so no column groups are</span>
<span class="comment">         * declared.</span>
<span class="comment">         */</span>
        ret = session-&gt;<a class="code" href="struct_w_t___s_e_s_s_i_o_n.html#a358ca4141d59c345f401c58501276bbb" title="Create a table, column group, index or file.">create</a>(session, <span class="stringliteral">&quot;table:calls&quot;</span>,
            <span class="stringliteral">&quot;key_format=r,&quot;</span>
            <span class="stringliteral">&quot;value_format=qrrSS,&quot;</span>
            <span class="stringliteral">&quot;columns=(id,call_date,cust_id,emp_id,call_type,notes)&quot;</span>);

        <span class="comment">/*</span>
<span class="comment">         * Create an index on the calls table with a composite key of cust_id</span>
<span class="comment">         * and call_date.</span>
<span class="comment">         */</span>
        ret = session-&gt;<a class="code" href="struct_w_t___s_e_s_s_i_o_n.html#a358ca4141d59c345f401c58501276bbb" title="Create a table, column group, index or file.">create</a>(session, <span class="stringliteral">&quot;index:calls:cust_date&quot;</span>,
            <span class="stringliteral">&quot;columns=(cust_id,call_date)&quot;</span>);

        <span class="comment">/* Populate the customers table with some data. */</span>
        ret = session-&gt;<a class="code" href="struct_w_t___s_e_s_s_i_o_n.html#afb5b4a69c2c5cafe411b2b04fdc1c75d" title="Open a cursor.">open_cursor</a>(
            session, <span class="stringliteral">&quot;table:customers&quot;</span>, NULL, NULL, &amp;cursor);

        cursor-&gt;<a class="code" href="struct_w_t___c_u_r_s_o_r.html#ad1088d719df40babc1f57d086691ebdc" title="Set the key for the next operation.">set_key</a>(cursor, <span class="stringliteral">&quot;customer #1&quot;</span>);
        cursor-&gt;<a class="code" href="struct_w_t___c_u_r_s_o_r.html#a27f7cbd0cd3e561f6a145704813ad64c" title="Set the value for the next operation.">set_value</a>(cursor,
            <span class="stringliteral">&quot;Professor Oak&quot;</span>, <span class="stringliteral">&quot;LeafGreen Avenue&quot;</span>, <span class="stringliteral">&quot;123-456-7890&quot;</span>);
        ret = cursor-&gt;<a class="code" href="struct_w_t___c_u_r_s_o_r.html#aac90d9fbcc031570f924db55f8a1cee3" title="Insert a record, and optionally overwrite an existing record.">insert</a>(cursor);

        cursor-&gt;<a class="code" href="struct_w_t___c_u_r_s_o_r.html#ad1088d719df40babc1f57d086691ebdc" title="Set the key for the next operation.">set_key</a>(cursor, <span class="stringliteral">&quot;customer #2&quot;</span>);
        cursor-&gt;<a class="code" href="struct_w_t___c_u_r_s_o_r.html#a27f7cbd0cd3e561f6a145704813ad64c" title="Set the value for the next operation.">set_value</a>(cursor, <span class="stringliteral">&quot;Lorelei&quot;</span>, <span class="stringliteral">&quot;Sevii Islands&quot;</span>, <span class="stringliteral">&quot;098-765-4321&quot;</span>);
        ret = cursor-&gt;<a class="code" href="struct_w_t___c_u_r_s_o_r.html#aac90d9fbcc031570f924db55f8a1cee3" title="Insert a record, and optionally overwrite an existing record.">insert</a>(cursor);

        ret = cursor-&gt;<a class="code" href="struct_w_t___c_u_r_s_o_r.html#ae5e6412ab3d895d68f454e59963fd391" title="Close the cursor.">close</a>(cursor, NULL);

        <span class="comment">/*</span>
<span class="comment">         * First query: a call arrives.  In SQL:</span>
<span class="comment">         *</span>
<span class="comment">         * SELECT id, name FROM Customers WHERE phone=?</span>
<span class="comment">         *</span>
<span class="comment">         * Use the cust_phone index, lookup by phone number to fill the</span>
<span class="comment">         * customer record.  The cursor will have a key format of &quot;S&quot; for a</span>
<span class="comment">         * string because the cust_phone index has a single column (&quot;phone&quot;),</span>
<span class="comment">         * which is of type &quot;S&quot;.</span>
<span class="comment">         *</span>
<span class="comment">         * Specify the columns we want: the customer ID and the name.  This</span>
<span class="comment">         * means the cursor&#39;s value format will be &quot;rS&quot;.</span>
<span class="comment">         */</span>
        ret = session-&gt;<a class="code" href="struct_w_t___s_e_s_s_i_o_n.html#afb5b4a69c2c5cafe411b2b04fdc1c75d" title="Open a cursor.">open_cursor</a>(session,
            <span class="stringliteral">&quot;index:customers:phone(id,name)&quot;</span>,
            NULL, NULL, &amp;cursor);
        cursor-&gt;<a class="code" href="struct_w_t___c_u_r_s_o_r.html#ad1088d719df40babc1f57d086691ebdc" title="Set the key for the next operation.">set_key</a>(cursor, <span class="stringliteral">&quot;212-555-1000&quot;</span>);
        ret = cursor-&gt;<a class="code" href="struct_w_t___c_u_r_s_o_r.html#a7e25b2ced2cf3ec68bd5429bf921c79f" title="Move to the record matching the key.">search</a>(cursor);
        <span class="keywordflow">if</span> (ret == 0) {
                ret = cursor-&gt;<a class="code" href="struct_w_t___c_u_r_s_o_r.html#af85364a5af50b95bbc46c82e72f75c01" title="Get the value for the current record.">get_value</a>(cursor, &amp;cust.id, &amp;cust.name);
                printf(<span class="stringliteral">&quot;Got customer record for %s\n&quot;</span>, cust.name);
        }
        ret = cursor-&gt;<a class="code" href="struct_w_t___c_u_r_s_o_r.html#ae5e6412ab3d895d68f454e59963fd391" title="Close the cursor.">close</a>(cursor, NULL);

        <span class="comment">/*</span>
<span class="comment">         * Next query: get the recent order history.  In SQL:</span>
<span class="comment">         *</span>
<span class="comment">         * SELECT * FROM Calls WHERE cust_id=? ORDER BY call_date DESC LIMIT 3</span>
<span class="comment">         *</span>
<span class="comment">         * Use the call_cust_date index to find the matching calls.  Since it is</span>
<span class="comment">         * is in increasing order by date for a given customer, we want to start</span>
<span class="comment">         * with the last record for the customer and work backwards.</span>
<span class="comment">         *</span>
<span class="comment">         * Specify a subset of columns to be returned.  If these were all</span>
<span class="comment">         * covered by the index, the primary would not be accessed.  Stop after</span>
<span class="comment">         * getting 3 records.</span>
<span class="comment">         */</span>
        ret = session-&gt;<a class="code" href="struct_w_t___s_e_s_s_i_o_n.html#afb5b4a69c2c5cafe411b2b04fdc1c75d" title="Open a cursor.">open_cursor</a>(session,
            <span class="stringliteral">&quot;index:calls:cust_date(cust_id,call_type,notes)&quot;</span>,
            NULL, NULL, &amp;cursor);

        <span class="comment">/*</span>
<span class="comment">         * The keys in the index are (cust_id,call_date) -- we want the largest</span>
<span class="comment">         * call date for a given cust_id.  Search for (cust_id+1,0), then work</span>
<span class="comment">         * backwards.</span>
<span class="comment">         */</span>
        cursor-&gt;<a class="code" href="struct_w_t___c_u_r_s_o_r.html#ad1088d719df40babc1f57d086691ebdc" title="Set the key for the next operation.">set_key</a>(cursor, cust.id + 1, 0);
        ret = cursor-&gt;<a class="code" href="struct_w_t___c_u_r_s_o_r.html#a8068ddce20d0775f26f6dac6e5eb209c" title="Move to the record matching the key if it exists, or a record that would be adjacent.">search_near</a>(cursor, &amp;exact);

        <span class="comment">/*</span>
<span class="comment">         * If the table is empty, search_near will return WT_NOTFOUND.</span>
<span class="comment">         * Otherwise the cursor will on a matching key if one exists, or on an</span>
<span class="comment">         * adjacent key.  If the key we find is equal or larger than the search</span>
<span class="comment">         * key, go back one.</span>
<span class="comment">         */</span>
        <span class="keywordflow">if</span> (ret == 0 &amp;&amp; exact &gt;= 0)
                ret = cursor-&gt;<a class="code" href="struct_w_t___c_u_r_s_o_r.html#a43d6664d2f68902aa63f933864242e76" title="Return the previous record.">prev</a>(cursor);
        <span class="keywordflow">if</span> (ret == 0)
                ret = cursor-&gt;<a class="code" href="struct_w_t___c_u_r_s_o_r.html#af85364a5af50b95bbc46c82e72f75c01" title="Get the value for the current record.">get_value</a>(cursor,
                    &amp;call.cust_id, &amp;call.call_type, &amp;call.notes);

        count = 0;
        <span class="keywordflow">while</span> (ret == 0 &amp;&amp; call.cust_id == cust.id) {
                printf(<span class="stringliteral">&quot;Got call record on date %lu: type %s: %s\n&quot;</span>,
                    (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)call.call_date, call.call_type, call.notes);
                <span class="keywordflow">if</span> (++count == 3)
                        <span class="keywordflow">break</span>;

                ret = cursor-&gt;<a class="code" href="struct_w_t___c_u_r_s_o_r.html#a43d6664d2f68902aa63f933864242e76" title="Return the previous record.">prev</a>(cursor);
                ret = cursor-&gt;<a class="code" href="struct_w_t___c_u_r_s_o_r.html#af85364a5af50b95bbc46c82e72f75c01" title="Get the value for the current record.">get_value</a>(cursor,
                    &amp;call.cust_id, &amp;call.call_type, &amp;call.notes);
        }
</pre></div>  </div></div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="index.html">Reference Guide</a>      </li>
      <li class="navelem"><a class="el" href="using.html">Writing WiredTiger applications</a>      </li>

    <li class="footer">Copyright (c) 2008-2012 WiredTiger.  All rights reserved.  Contact <a href="mailto:info@wiredtiger.com">info@wiredtiger.com</a> for more information.</li>
   </ul>
 </div>


</body>
</html>
